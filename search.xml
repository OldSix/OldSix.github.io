<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[冷门小技巧 之 C/C++ 持续更新ing]]></title>
      <url>%2F2017%2F03%2F21%2F%E5%86%B7%E9%97%A8%E5%B0%8F%E6%8A%80%E5%B7%A7-%E4%B9%8B-C-C-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0ing%2F</url>
      <content type="text"><![CDATA[把时间用在思考上是最能节省时间的事情.—— 卡曾斯 本文主要介绍的一些冷门的, 诡异的, C/C++方面的小技巧, 持续更新ing. 字符串不需要换行直接使用 123456char buf[1024] = "hello" "world" "haha";//效果等价于:char buf[1024] = "helloworldhaha"; 这有什么鬼用呢? 在http组包头的时候,可以直接拼就好了,而已便于观看 1234char buf[1024] = "GET /xxx.html HTTP/1.1\r\n" "Host: 127.0.0.1:80\r\n" "Connection: keep-alive\r\n" "\r\n"; 是不是很好用? 2.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[搭建自己的Blog]]></title>
      <url>%2F2017%2F03%2F21%2F%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84Blog%2F</url>
      <content type="text"><![CDATA[思想以自己的言语喂养它自己，而成长起来。—— 泰戈尔 Hexo搭建记现在想想, 搭建个人的Blog真心是一件麻烦的事情, 每遇到一个问题, 那种痛苦的感觉, 解决了之后, 那种爽快的感觉, 其实跟编程给人的感觉差不多少. 在很久之前就一直想做一个自己的blog, 也买了域名, 折腾了一会, 但是就是感觉没有一篇文章是给小白, 纯小白看的, 就好像说, 把大象关进冰箱一样, 打开冰箱门, 你肯定知道, 然后大神们就告诉你说, 然后把大象放进冰箱里就行, 最后把冰箱门关上, done! 成功了有没有!….有些夸张, 但是有时候感受是这样的 前几天,偶然的一次访问到了一位网友的博客, 博客的页面简单, 美观, 实用, 又一次燃起了我对个人主页的向往, 于是, 折腾开始了.. 其实, 网上也参考不少好的资料, 在本文末尾, 也一一列出, 并在此感谢各位大神的著作, 让我度过了坎坷但又很值得的几天, 人生就是要浪费在这种美好的事物上呀! 下面, 我来给出我的详细搭建过程中, 遇到关于域名解析的一些问题, 进行一下简单的说明. 像简单的一些页面配置, 文章最后, 我列出的参考文献之中, 均有详细无比的配置方法, 就不在此赘述. 1.1 购买域名 我是直接去狗爹上, 搜索到自己想要的域名, 然后购买就可以, 简单, 而且可以直接支付宝付款. 1.2 域名解析啥意思呢? 就是说, 你虽然买了一个域名, 但是还是要解析才能使用, 比如说, 我自己买了一个域名是xxxx.me, 但是实际上你托管代码的服务器, 只让你通过www.xxxx.me来访问, 不允许你直接访问自己的域名, 怎么破?这个时候就需要一个dns解析服务, 来帮助, 而且还有一个CNAME的概念. 我使用的DNS解析服务是来自DNSPod, 注册简单, 使用也比较方便, 在域名解析标签下, 添加自己的购买的域名, 然后再根据设置向导, 修改狗爹上的一些配置, 其实就是访问自己的域名时, 狗爹的服务器优先感知到, 然后再反向通知到你刚刚注册的DNSPod的NameServer上去, 进而进行解析, 其实也就是再一步的跳转到你设置的那个真实的服务器的ip地址上去, 获取到你页面文件, 浏览器才能进行展示. 这个再跳转的过程就是 要配置的 CNAME我是使用的GitHub提供的代码托管服务.DNSPod中的CNAME选项按照要求GitHub配置上就好, ‘过程就是, 访问 www.xxx.me , 狗爹服务器响应, 然后跳转到DnsPod服务器, 然后根据CNAME再跳一次, 跳到GitHub的服务器上面, 最后才算是完成了一次访问. 1.3 直接访问域名其实我还有一个问题, 一直没有解决, 就是我CNAME虽然按照DNSPod的方式配置, GitHub的二级域名也填好了, 是直接访问的方式, 但是我直接访问时, 却一直会跳转到狗爹的页面上去, 而不会跳转的GitHub上的部署服务器上, 但是如果使用www访问,就可以直接访问成功.123不知道是不是我购买的域名不支持?还是DNSPod的配置还是有问题?还是GitHub上不支持? 唉 , 以后再慢慢来弄吧~ 先好好写点文章先.. 参考文献 Hexo你的博客 Hexo独立博客 NexTGitHub Next使用文档]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux多线程传参问题]]></title>
      <url>%2F2017%2F03%2F21%2FLinux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BC%A0%E5%8F%82%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[寿命的缩短与思想的虚耗成正比。—— 达尔文 在Linux多线程创建函数pthread_create中, 它的最后一个参数, 允许线程回调函数中传入一个参数, 一直以来, 我们被警告尽量不要在这个参数中传递指针, 尽量进行值传递.. 但是为什么呢? 下面, 我们来看这样一段代码: 123456789101112131415161718192021222324252627282930313233343536373839typedef struct ThreadInfo_&#123; void *handle; int iLoop; int iArrayIndex;&#125; ThreadInfo;void *start_routine(void *arg)&#123; ThreadInfo *threadInfo = (ThreadInfo *)arg; for( int i = 0 ; i &lt; threadInfo-&gt;iLoop ; ++ i ) printf("第%d线程, 第%d圈", threadInfo-&gt;iArrayIndex, i+1);&#125;int main(void)&#123; pthread_t pidArray[1024]; ThreadInfo threadInfo; memset( &amp;threadInfo , 0 , sizeof(ThreadInfo) ); void *handle = NULL; int iLoop = 2; for( int i = 0 ; i &lt; 10 ; ++ i )&#123; threadInfo.handle = handle; threadInfo.iLoop = iLoop; threadInfo.iArrayIndex = i+1; pthread_create( &amp;pidArray[i] , NULL , start_routine , (void*)&amp;threadInfo ); &#125; for( int i = 0 ; i &lt; 10 ; ++ i ) pthread_join( pidArray[i] , NULL ); return 0;&#125; 很简单的一段逻辑, 我们有这样一个需求: 创建10个线程,每个线程打印: 当前线程在处理第几圈, 打印顺序当然是不确定的 预期: “第1线程, 第1圈”“第2线程, 第1圈”“第3线程, 第2圈”“第4线程, 第1圈”“第5线程, 第2圈”… 实际上: “第10线程, 第1圈”“第10线程, 第1圈”“第10线程, 第2圈”“第10线程, 第1圈”“第10线程, 第1圈”“第10线程, 第2圈”“第10线程, 第1圈”“第10线程, 第2圈”“第10线程, 第2圈”… 打印的结果, 大大的出乎我们的意料, 没有按照我们之前的预想, 都是打印出第10个线程在做事.为什么会这样呢? 原因其实也不难分析: 我们仔细再回顾一下代码, 不难发现一个问题, 那就是threadInfo这个东西, 在主线程中, 其实只被创建了一次, 而每次for循环中, 进行修改它的内容而已. 貌似问题是出在这里, 这还不够. 我们还知道这样几个事实, 那就是这段代码中: 主线程函数栈和子线程函数栈其实都是同一个进程的栈空间内的; 主线程在创建10个子线程的整个过程中, 一直是不会被打断的; 10个子线程看似是一个个创建出来的, 但是其实相当于10个线程并发着创建出来, 然后一起去抢占cpu的资源的; 主线程和子线程抢占cpu的能力上, 大概是 主线程会优先90%抢占, 理论依据不足, 这里主要是经验值. 好, 这几个事实的基础上, 我们知道了10个子线程一起创建好了, 然后去抢占资源, 抢到了然后去执行回调函数, 处理相关的逻辑. 而且, 主线程也不会等待或阻塞, 依次继续执行, 那么, 控制线程编号的变量, iArrayIndex其实本质上, 是在主线程自己的栈帧中的, 开辟关于threadInfo的一段空间, 空间里有一个 iArrayIndex 变量的内容. 再看子线程空间, 线程空间中, 由于是通过指针的方式获取到 threadInfo的值, 那么,线程不断的抢占, 然后通过指针访问主线程栈帧中的一个变量中的一个属性内容, 而且, 这个内容在主线程中不断的自增变化. 而且, 主线程有90%的几率优先抢占到资源, 所以整个for循环执行完, iArraryIndex 已经自增为10, 这时, 子线程们才陆陆续续抢到cpu, 然后去回调, 而且, 还是通过指针, 访问主线程的栈帧中的iArrayIndex变量, 所以打印结果当然全是线程10咯~~ 如何解决呢?1 方法很简单, 尽量不要指针传递因为创建过程中, 被指向的对象很可能已经在主线程中发生变化, 比如本题中.不变化的话, 就可以传了吗? 接着看. 2. 一定要使用怎么办 答案就是: 内存冗余法. 啥意思呢?说白了, 就是避免麻烦, 避免出现本文中的出现的类似的问题, 我给每个子线程生成一个变量就好了, 每人一份, 不用抢. 当然, 这一份变量要开辟在堆空间上. 其实也就是类似, 参考了 多进程中的做法, 就是fork之后, 原来父进程有的, 我几乎全copy一份( 有些PCB中的内容不会拷贝到子进程中去 ), 互不干扰. 总结多线程中的使用中, 这个传参的过程还是有点小坑的, 很多问题, 同一个线程中, 似乎很简单, 但是多线程, 而且感觉看不到摸不到, 调用时机也不明确, 会让我们觉得有点困扰. 但是仔细分析, 画图辅助, 其实问题解决起来也不难. 示意图如下:]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[浅谈算法 之 并查集]]></title>
      <url>%2F2017%2F03%2F20%2F%E6%B5%85%E8%B0%88%E7%AE%97%E6%B3%95-%E4%B9%8B-%E5%B9%B6%E6%9F%A5%E9%9B%86%2F</url>
      <content type="text"><![CDATA[我不能说我不珍重这些荣誉，并且我承认它很有价值，不过我却从来不曾为追求这些荣誉而工作。—— 法拉第 并查集1 概念 并查集本身是一种特殊的树形结构,看似有点奇怪,因为它某些实现方式可能并没有使用到关于树的任何节点之类的东西,但是原理上,就是这样. 2 基础并查集存在的最大意义就是为了,高效地回答一个问题:1isConnect ( int p , int q ) 也就是判断 两个节点是否连接 问题.正是这一点,也是它作为图论基础的一个重要原因,图论关于路径问题很多时候,都会使用并查集这种概念来解决其中一些逻辑.其实很多基础数据结构都是为了辅助高级算法中的某一环节的问题而存在的. 2.1 连接问题 与 路径问题 连接问题相比路径问题,回答的问题要少很多,因为它只关心两个节点是否相连,这也正是并查集高效的根本原因. 一个算法可以回答问题越多,其实不见得这个算法越高效,反而,可能这个算法是越低效的,这一点特别重要.或者说, 一个算法如果回答的问题越少, 其实也是提升算法效率的一个重要思路. 比如: 二分查找法 和 顺序查找法 相比快速排序 partition堆 再看什么是连接的问题? 网络中节点的连接状态用户之间形成的网络道路交通航班调度 2.2 并查集的两个基本操作,是的,就两个:1234find( int p )union( int p , int q)// 注意,这里的union不是联合体的意思,是合并操作的意思 2.3 另外 并查集也可以实现数学中的集合类. 3 实现这里介绍的并查集底层实现方式都是使用数组来实现的. 3.1 QuickFindQuickFind见名知义,就是find操作的实现比较快.问题: 效率太低. 123456789101112131415161718192021222324252627282930class UnionFind&#123;private: int * id; int count;&#125;;// O(1)int find( int p )&#123; assert( p &gt;= 0 &amp;&amp; p &lt; count ); return id[p];&#125;int isConnected( int p , int q)&#123; assert( p &gt;= 0 &amp;&amp; p &lt; count ); assert( q &gt;= 0 &amp;&amp; q &lt; count ); return id[p] == id[q];&#125;// O(n)void unionElements( int p , int q )&#123; int pID = find(p); int qID = find(q); if( qID == pID) return; for( int i = 0 ; i &lt; count ; ++ i ) if( qID == id[i] ) id[i] = pID;&#125; 其实从代码我们也可以看出,其实find操作,在图中的,其实就是查找当前节点所在的连通分量的值.union的操作其实就是合并两个连通分量. 因为对于两个连通分量来说, 只要各自有一个点相连接了, 那么两个连通分量都连在一起了. 3.2 QuickUnionQuickUnion见名知义,就是union操作的实现比较快.思路上,发生了一点变化: 每个节点缓存了自己的父节点的值其实这个思路,就是类似于树的父节点的概念,但是实现了并没有引入指针的概念 问题: 一定程度上,缓解了QuickFind的效率低下的问题,但是还不够 实现如下: 12345678910111213141516171819202122232425262728class UnionFind&#123;private: int * parent; int count;&#125;;int find( int p )&#123; assert( p &gt;= 0 &amp;&amp; p &lt; count ); while( p != parent[p] ) p = parent[p]; return p;&#125;int isConnected( int p , int q)&#123; return find(p) == find(q);&#125;void unionElements( int p , int q )&#123; int pRoot = find(p); int qRoot = find(q); if( qRoot == pRoot) return; // q节点的根节点, 指向p节点的根节点 parent[pRoot] = qRoot;&#125; 虽然实现上并没有引入根节点,或者使用指针概念( 因为并查集中的节点只有父节点概念, 所以用数组来保存节点值即可 ), 但是本质上, 在开头也提到了, 并查集虽然是一棵特殊的树, 但是还是具有树的性质: 当树高度很深时, 树的遍历效率会大大降低. 类似于普通平衡二叉树也有类似的问题,所以才引入了2-3树和红黑树的概念. 在并查集中,也存在这样类似的问题, 所以便有了下面的两种优化 3.2.1 基于size的优化思路也很简单,就是在union操作中,不是随意的将两个连通分量直接合并,而是根据元素的个数,优先将元素少的集合, 合并到元素多的连通分量中. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#ifndef UNIONFIND_UNIONFIND3_H#define UNIONFIND_UNIONFIND3_H#include &lt;cassert&gt;namespace UF3&#123; class UnionFind&#123; private: int * parent; int count; int * sz;// sz[i] 表示i为根节点的集合中元素个数 public: UnionFind( int count )&#123; parent = new int[count]; sz = new int[count]; this-&gt;count = count; for( int i = 0 ; i &lt; count ; ++i )&#123; parent[i] = i; sz[i] = 0; &#125; &#125; ~UnionFind()&#123; delete[] parent; delete[] sz; &#125; int find( int p )&#123; assert( p &gt;= 0 &amp;&amp; p &lt; count ); while( p != parent[p] ) p = parent[p]; return p; &#125; bool isConnected( int p , int q )&#123; return find(p) == find(q); &#125; void unionElements( int p , int q )&#123; int pRoot = find(p); int qRoot = find(q); if( pRoot == qRoot ) return; // 节点少的并到节点多的集合中 if( sz[pRoot] &gt; sz[qRoot] ) &#123; parent[qRoot] = pRoot; sz[pRoot] += sz[qRoot]; &#125; else &#123; parent[pRoot] = qRoot; sz[pRoot] += sz[qRoot]; &#125; &#125; &#125;;&#125;#endif //UNIONFIND_UNIONFIND3_H 3.2.1 基于rank的优化关于size的优化其实可以解决大部分的场景, 但是其实还是不够,还是以上那个情况,就是元素个数,其实并不能完全解决并查集的树高度过深的问题,所以再次修改代码如下:思路很简单, 一句话, 就是把树的高度低的集合合并到高的树的集合中. 100万量级可以做到1s内处理 – union和 判断连接 两个操作. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#ifndef INC_05_OPTIMIZE_BY_RANK_UNIONFIND3_H#define INC_05_OPTIMIZE_BY_RANK_UNIONFIND3_H#include &lt;cassert&gt;using namespace std;namespace UF3&#123; class UnionFind&#123; private: int* parent; int* rank; // rank[i]表示以i为根的集合所表示的树的层数 int count; public: UnionFind(int count)&#123; parent = new int[count]; rank = new int[count]; this-&gt;count = count; for( int i = 0 ; i &lt; count ; i ++ )&#123; parent[i] = i; rank[i] = 1; &#125; &#125; ~UnionFind()&#123; delete[] parent; delete[] rank; &#125; int find(int p)&#123; assert( p &gt;= 0 &amp;&amp; p &lt; count ); while( p != parent[p] ) p = parent[p]; return p; &#125; bool isConnected( int p , int q )&#123; return find(p) == find(q); &#125; void unionElements(int p, int q)&#123; int pRoot = find(p); int qRoot = find(q); if( pRoot == qRoot ) return; if( rank[pRoot] &lt; rank[qRoot] )&#123;// 树的高度不变, 仔细琢磨一下 parent[pRoot] = qRoot; &#125; else if( rank[qRoot] &lt; rank[pRoot])&#123;// 同理, 树的高度也不变 parent[qRoot] = pRoot; &#125; else&#123; // rank[pRoot] == rank[qRoot] // else的逻辑是整段代码的核心 // 高度相等时候的合并, 最后的高度 += 1 即可 parent[pRoot] = qRoot; rank[qRoot] += 1; &#125; &#125; &#125;;&#125;#endif //INC_05_OPTIMIZE_BY_RANK_UNIONFIND3_H 3.2.3 路径压缩其实,也是基于QuickUnion的一个优化,但是优化的重点,放在find上. 在find的过程中,再次通过技术手段,降低树的高度. 1234567891011int find( int p )&#123; assert( p &gt;= 0 &amp;&amp; p &lt; count ); while( p != parent[p] )&#123; // p的父节点指向当前父节点的父节点, 这就是路径压缩的核心, 没了 // 需要注意的就是,即使当前距离根节点只有一个位置了,下面代码依然成立 // 因为根节点的父节点仍然等于自己 parent[p] = parent[parent[p]]; p = parent[p]; &#125; return p;&#125; 继续优化:12345678910int find( int p )&#123; assert( p &gt;= 0 &amp;&amp; p &lt; count ); // 这段代码的作用, 是把所有除根节点外的节点,都直接优化成是根节点的第一子节点 // 也就是说,除了根节点外, 所有节点都在一层, 而树的高度就是两层. // 这样的做法,查找效率就是最高的. if( p != parent[p] ) parent[p] = find( parent[p] ); return p;&#125; 但是, 这只是理论上的分析,实际上,第一个版本的路径压缩优化,在时间效率上其实是高于递归版本的路径压缩优化方法,虽然递归版本中,从逻辑上,树高度上的优化,其实已经做到了极致, 就差把树变成了一个数组, 看似是应该更快的.. 但是, 这其中的消耗其实主要来自递归的开销. 所以,有时候从逻辑上分析之后,我们还应该手动的检验一下最后的结果, 因为理论有时候往往不一定可靠. 4 时间复杂度最终优化后的并查集的操作, 时间复杂度近乎是 O(1) 的, 准确的说不是O(1), 因为其实在操作的过程中, 还是会有一定的开销, 这个消耗的具体内容, 感兴趣的读者可以自行谷歌一下. 算法, 是不是很有意思呢?]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Dynamic & Static Library]]></title>
      <url>%2F2017%2F03%2F20%2FDynamic-Static-Library%2F</url>
      <content type="text"><![CDATA[Microsoft isn’t evil, they just make really crappy operating systems.—— Linus Torvalds 本文是一篇干货,主要展示了Linux和Windows下,静态库和动态库的生成方法. 0 动态库基础1. win下,动态库 -- xxx.dll / xxx.lib xxx.h 2. Linux下,动态库 --- xxx.so xxx.h -L -l 1 Linux(1) 制作Linux动态库 12gcc -c xxx.c -o xxx.o -fPICgcc -shared -o libxxxtest.so xxx.o 多文件项目中,可以参看我的另一篇关于 makefile 的介绍 (2) 动态库的使用 lib库名.so 文件本身不能执行 项目目录结构如下:123456src/ -- xxx.cobj/ -- xxx.o 用于tiainc/ -- xxx.h 头文件lib/ -- xxx.so / xxx.a 库media/ -- 媒体文件Makefile 执行命令如下:123链接器: 工作于生成可重定位文件阶段,也就是生成.o文件.任务:数据合并 和 地址回填(数据位置重定位)动态链接器: 工作于加载器加载可执行文件到内存后,程序运行时查找库函数期间.加载库函数到内存,重定位函数地址(绝对地址),用LD_LIBRARY_PATH. 运行: ./a.out —&gt;报错12原因: 动态链接器找不到加载库函数的目录位置.ldd a.out 查看链接依赖情况, 是否存在&apos;not found&apos;字样 解决方案:12345(1) 将自定义的动态库 cp 放到 标准 c库所在目录位置: /usr/bin/lib (不推荐)(2) 在可执行文件所在目录的位置, 执行命令: export LD_LIBRARY_PATH = 库路径 (临时生效)(3) export LD_LIBRAY_PATH = 库路径 写入 ~/.bash_profile 中, source 一下 令其即时生效, 或重启.ldd 再次查看,成功显示动态库位置 ./a.out 运行即可 2 Windows(1) 动态库的制作: 打开vs2013 , 创建win32 生成dll项目 动态库的命名不要使用中文名 导入src文件 API函数导出即可 只将用户使用的指定某几个函数从动态库中导出。 — xxx.lib 使用 __declspec(dllexport) 宏，提示编译器。在编译程序的时候，需特殊处理的函数。 注意： .c 文件 和 .h 文件 均需要添加该宏！！ （VS2013 要求） 默认生成的动态库位于上层目录下的 Debug 目录内。 (2) 动态库的制作结果12345xxx.dll 二进制目标函数集, 可被操作系统加载xxx.lib 是对dll的描述文件( 包含多少函数, 哪些被导出 )xxx.h 以上三个文件提供给用户使用即可 (3) 动态库的调用和调试1234567通知VS2013编译器，使用提供的动态库。将.dll .lib .h三个文件放置在 .c同级目录下。右键项目“属性”---“配置属性”---“链接器”---“输入”--- “附加依赖项”---下拉菜单“编辑”---- 输入【描述dll信息lib文件 xxxxx.lib】 常见错误：12345678910111. 若xxx.lib配置错误，则VS编译器无法找到所用函数。 2. 如若在运行111.exe时，说明操作系统找不到动态库加载路径。 (1)配置PATH;(2)将exe和动态库dll置于同一目录下即可。VS2015： xxxx.lib ---&gt; .c 源码 .h 头文件所在目录位置 xxxx.dll ---&gt; .exe 可执行文件所在目录位置。 动态库内存释放：12遵循一个原则：谁分配，谁释放。调用动态库函数分配的内存，也一定要调用动态库函数来释放内存。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MakeFile]]></title>
      <url>%2F2017%2F03%2F19%2FMakeFile%2F</url>
      <content type="text"><![CDATA[人的一切痛苦,本质上都是对自己的无能的愤怒—— 王小波 1 定义MakeFile 是一种经典的项目管理工具.其实也是一种脚本,有着自己独特的语法. 2 基本使用Makefile元素:12目标: 依赖 (tab 缩进)命令 目标可以有多个依赖,依赖有传递性.make命令去执行Makefile,Makefile的名字固定为Makefile或者makefile,也可以自定义名字,但需要-f指定. 原理: 当依赖文件, 有更新时, 就会生成新的目标文件, 否则make指令不做什么操作. make默认生成第一个依赖项.如果想生成其他依赖项,直接在make后跟依赖项即可.比如:12345678910111213141516171819202122&gt; make clean# 当makefile文件夹中, 恰好有一个文件名就叫 clean , 那么此时, make clean 动作会失效.# 为什么失效呢?# 因为, 如果目录中出现了&quot;clean&quot;文件，则规则失效了：没有依赖文件，文件&quot;clean&quot;始终是最新的，命令永远不会执行# 也就是, 编译器把 clean 当作了要生成的一个目标文件, # 比如 最简单的 a.out:# gcc a.c -o $@# 如果文件夹中恰好有这样一个 a.out 时, 那么 make 命令就是失效. 同时 clean 的失效也是来自这个道理. clean: rm $@ $(objs) -rf.PHONY: ALL clean# .PHONY: ALL clean 的意思就是强制执行 clean 下的命令, 无视同名文件# 一般可能还要配合sudo命令来使用&gt; make install&gt; make uninstall# 主要用来测试# echo $(CC)&gt; make test 一般的,把第一个目标叫做all 1234# 首次查看,切记要执行, 输出具体指令, 防止误操作造成不可逆转的行为&gt; make -n 3 变量可以使用变量来简化Makefile,定义变量可以使用 定义一个变量12345678# := 表示立即赋值,推荐使用# 也可以使用 = , 使用时才赋值libname := libxxx.so objs := a.o b.o c.oa.out: $(objs) gcc $^ 环境变量shell中的环境变量可以在makefile脚本中直接使用.比如 PATH. 12# 注意空格需要转义才行export objs = a.o\ b.o\ c.o 另外,当本地变量与环境变量重名时,本地变量会覆盖环境变量. 自动变量1234567$^ 在规则的命令中, 表示所有依赖项$&lt; 在规则的命令中, 表示第一个依赖项. 在模式规则中, 可以将依赖项依次取出.$@ 在规则的命令中, 表示目标$? 表示所有比目标文件更&quot;新&quot;的依赖文件列表用于文件拷贝时,有特殊的用途 模式规则: %: %.c gcc $&lt; -o $@ -Wall -g 静态模式规则: $(target):%: %.o gcc $&lt; -o $@ -L$(lib_path) -l$(libname) -I$(inc_path) 4 缺省规则缺省规则是make系统提供的默认的规则,比如 x.o1234567%.o: %.c $(CC) -c $(CPPFLAGS) $(CFLAGS) $&lt;# % 是通配符的意思,表示任意的.o文件# $(CC) 就是cc,也就是gccls -al /usr/bin/cc 可以看出, cc就是gcc的一个软链接而已 5 函数的使用两个函数 1234567891011# 获取含有某一特征的文件组成列表$(wildcard 参数1)使用:srcs = $(wildcard *.c) # srcs = a.c b.c s.c----------------# 替换objs = $(patsubst %.c, %.o , $(srcs)) # 将第三个参数中的,第一个参数的部分,替换为第二个参数objs = a.o b.o s.o 6 一些高级用法主要是shell命令的内置用法 1234srcs := `ls *.c`srcs := $(shell ls *.c)objs := $(srcs:.c=.o) 案例1123456789101112131415CXX = g++ CXXFLAGS = -g -I. -Wall SRCS = $(shell find -name &quot;*.cpp&quot;) OBJECTS = $(SRCS:%.cpp=%.o) TARGETS = $(SRCS:%.cpp=%) all: $(TARGETS) @for target in $(TARGETS); \ do \ $(CXX) $(CXXFLAGS) -o target target.cpp; \ doneclean: -rm -f $(TARGETS) $(OBJECTS) 案例21234567files=main.exe a.exe b.exe all: for name in `echo $(files) | sed s/.exe//g`; \ do \ rm -f &quot;$$name&quot;.o; \ done 1234567891011121314151617181920src = $(wildcard ./src/*.c)obj = $(patsubst ./src/%.c, ./obj/%.o, $(src)) target = $(patsubst ./src/%.c, ./%, $(src))inc_path = ./inclib_paht = ./liblibname = xxxsocketALL:$(target)$(target):./%:./obj/%.o gcc $&lt; -o $@ -L$(lib_paht) -l$(libname) -I$(inc_path)$(obj):./obj/%.o:./src/%.c gcc -c $&lt; -o $@ -L$(lib_paht) -l$(libname) -I$(inc_path)clean: -rm -rf $(obj) $(target).PHONY: ALL clean 7 常见操作目录迭代问题解决方案:(1) 在目录中继续生成一个Makefile文件(2) make -C sub 示例: 子Makefile问题将一些常用的修改属性合并到一个子文件中去命名: def.mk12-include def.mk# 前面的 - 号指的是,如果文件不存在,自动忽略,不要报错 自动推导12&gt; gcc -MM a.c&gt; # 查看a.c的文件依赖命令 方法描述:1234&gt; 临时生成一份 .d 文件&gt; 文件的内容就是 x.o 的所有文件依赖&gt; 只要在makefile文件中下,-include $(deps)也就相当于, 在马克file文件中写入这样依据依赖: a.o: a.c a.h 示例: 7 其他用途文件拷贝123456# 找到A目录下的所有普通文件(1) file_in_A := $(shell find A -type f)(2) Makefile: $(file_in_A) cp $? b # 复制所有最近更新的文件 touch Makefile 8 最后 因为makefile的写法还是过于复杂,现在实际应用中已经较少有人使用makefile,与之替代的是CMake和QMake,但是底层其实都是基于makefile的实现,所以关于makefile我们还是要知道了解一些为好.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[浅谈算法 之 索引堆]]></title>
      <url>%2F2017%2F03%2F19%2FIndexHeap%2F</url>
      <content type="text"><![CDATA[没有人不爱惜他的生命，但很少人珍视他的时间。—— 梁实秋 这里主要讨论的是，数组化的实现堆的经典方法。 1 为什么要使用索引堆 索引堆从名称也可以看得出来，是堆的一种高级形态 有这样一个基础概念，想在此强调一下，那就是： 对于堆化的过程中，原来数组的索引将被破坏掉。 这也是就是索引堆的意义，或者说索引堆的核心价值。 就是因为普通堆在成堆之后，数组的高效索引能力被严重破坏掉，因为成堆之后的下标与原始数据之后没有做关系维护。 这个时候就需要另外一个数组来维护原始数据和成堆后的数据之间的关系。 另外，还有一个问题： shiftUp和shiftDown中的交换操作 在普通堆中，shiftUp和shiftDown中都要进行一步交换两个节点之间的值的步骤，但是如果节点值只是简单的数字，也是交换操作不会造成太大的影响，但是如果不是数字呢，而是一个字符串，或者一个更大的数据类型时，那么交换带来的副作用将会被大大提升。 p.s. 当然这里交换的操作，我们可以简单的通过一些技术手段来替代。 所以，这时，我们的英雄登场了：索引堆，先来看看它的数据结构。 2 索引堆的数据结构索引堆在普通堆的基础之上，其实多维护了一个indexes数组而已，它记录着data中的索引，在堆中的位置，也就是indexes[i] = x 的意思就是，data[x]这个元素，在堆中的实际位置是 i。 看下索引堆的数据结构：123456template &lt;typename Item&gt;class IndexMinHeap&#123;private: Item * data; int * indexes;&#125;; 3 索引堆过程索引堆的整个操作中，并没有对原始数据进行任何操作（只是用来比较），而真正处理的索引数组indexes中的索引，把索引进行了一次堆排序。 这样就根本上避免了数组中交换元素可能带来的副作用，而且相应的带来另外一个巨大的好处：直接可以索引到6号元素——data[6]，这在原始堆的实现过程中，是无法实现的，因为堆的索引性质在成堆过程中被破坏，只能简单的拿到堆的根节点（最大或者最小）。 因为成堆的过程，数组变成一棵树的容器，索引性还在，但是树中的，尤其在堆中的这种树，其实我们只关心根节点，对其他任何节点没有索引意义，原来的第6号元素，跟现在树中的6号元素没有任何关联。 但是，索引堆的中data数组没有被修改，仍然是一个数组性质，而且还可以通过indexes数组找到，data中元素在堆中的位置，indexes[位置] = data对应的下标，如简单的，根节点的位置就是 indexes[1] 的值，也就是data中对应元素的下标位置。 4 调整优先级而且，还可以进行一个重要的操作：change 修改原始数据的优先级，或者可以简单的理解为，修改了原始数据的值。 wow, this really kicks original heap&#39;s ass 5 Reverse 数组索引堆如此厉害，但是与此同时，又带来了一个新的问题： indexes数组成堆的过程中，indexes数组的索引意义也不在了，我们不能快速的（O(1)）获取到，比如1号索引在堆中的位置，因为所有的索引都被打乱了。 所以在change过程中，我们获取到了data元素的下标，如果得知这个下标在堆中的位置呢？ 这个时候，就又用到了一个数组，来维护indexes数组中的下标与堆中位置的关系，也就是reverse数组。 再看下，此时的索引堆的数据结构：1234567template &lt;typename Item&gt;class IndexMinHeap&#123;private: Item * data; int * indexes; int * reverse;&#125;; 可能上面的说法，还是不足够清晰的表达出来，到底reverse数组的意义是什么？ 其实主要就为了一个change函数可以以 O(1) 的时间复杂度来访问到，要修改的元素在索引堆的位置。 简单的，我们可以得到以下的等式：1234567// 堆中i位置上对应的data的下标，也就是j// 也就是data[j]，在堆中的实际位置是i// 或者说，堆中i的位置是，data[j]的下标jindexes[i] = j;// 堆中j的位置是，indexes[i]的下标ireverse[j] = i; 所以呢，再次看出来，如果想与堆中的索引建立联系，必须要多维护一个数组。 6 不断维护Reverse和Indexes数组 只要是操作indexes的地方，都要相应的操作reverse数组，进行匹配 7 应用 对索引堆的使用，在图论中关于有权图，单源最短路径问题的算法中，比如Dijkstra算法和Bellman-Ford算法中都有使用，用来维护最短权值的数组。 最后，附上源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163#ifndef INDEXMINHEAP_INDEXMINHEAP_H#define INDEXMINHEAP_INDEXMINHEAP_H#include &lt;cassert&gt;#include &lt;algorithm&gt;template &lt;typename Item&gt;class IndexMinHeap&#123;private: // 原始数据，对原始数据并不需要进行实际的操作，下标不变 Item * data; // indexes[i]表示堆中第i个元素在data中索引 // 比如indexes[1] = 10，也就是说，堆的根节点，是data中的10号元素 int * indexes; // reverse[i]表示索引i在indexes(堆)中的位置 // reverse[10] = 1，也就是说，10号索引在堆中的位置是1号元素，也就是根节点 // reverse[x] = 0; 表示索引不存在 int * reverse; int count; int capacity; void shiftUp( int k )&#123; while( k &gt; 1 &amp;&amp; data[indexes[k]] &lt; data[indexes[k/2]] )&#123; std::swap( indexes[k] , indexes[k/2] ); reverse[indexes[k]] = k; reverse[indexes[k/2]] = k/2; k /= 2; &#125; &#125; void shiftDown( int k )&#123; while( 2*k &lt;= count )&#123; int i = 2*k; if( i+1 &lt;= count &amp;&amp; data[indexes[i]] &gt; data[indexes[i+1]] ) i += 1; if( data[indexes[k]] &lt;= data[indexes[i]] ) break; std::swap( indexes[k] , indexes[i] ); reverse[indexes[k]] = k; reverse[indexes[i]] = i; k = i; &#125; &#125;public: IndexMinHeap( int capacity )&#123; data = new Item[capacity+1]; indexes = new int[capacity+1]; reverse = new int[capacity+1]; for( int i = 0 ; i &lt; capacity ; ++ i ) reverse[i] = 0; this-&gt;capacity = capacity; this-&gt;count = 0; &#125; ~MinHeap()&#123; delete[] data; delete[] indexes; delete[] reverse; &#125; int size() const&#123; return count; &#125; int isEmpty() const&#123; return count == 0; &#125; // 传入的i对于用户而言，是从0开始索引的 void insert( int i , Item item )&#123; assert( count + 1 &lt;= capacity ); assert( i + 1 &gt;= 1 &amp;&amp; i + 1 &lt;= capacity ); i += 1; count += 1; data[i] = item; indexes[count] = i;// 把data中的索引i，放入indexes数组 reverse[i] = count;// 把indexes中的索引i，放入reverse数组 shiftUp( count ); &#125; Item extractMin()&#123; assert( count &gt; 0 ); Item ret = data[indexes[1]]; std::swap( indexes[1] , indexes[count] ); reverse[indexes[1]] = 1; reverse[indexes[count]] = 0; count --; shiftDown( 1 ); return ret; &#125; int extractMinIndex()&#123; assert( count &gt; 0 ); int ret = indexes[1] - 1;// 返回从0开始的索引值 std::swap( indexes[1] , indexes[count] ); reverse[indexes[1]] = 1; reverse[indexes[count]] = 0; count --; shiftDown( 1 ); return ret; &#125; Item getMin()&#123; assert( count &gt; 0 ); return data[indexes[1]]; &#125; int getMinIndex()&#123; assert( count &gt; 0 ); return indexes[1] - 1;// 返回从0开始的索引值 &#125; // 对用户而言，参入的参数就是实际的数据的下标，且是从0开始的索引 Item getItem( int i )&#123; assert( i+1 &gt;= 1 &amp;&amp; i+1 &lt;= capacity ); return data[i+1]; &#125; bool contain( int i )&#123; assert( i + 1 &gt;= 1 &amp;&amp; i + 1 &lt;= capacity ); return reverse[i+1] != 0; &#125; void change( int i , Item newItem )&#123; i += 1; data[i] = newItem; // 找到indexes[j] = i, j表示data[i]在堆中的位置 // 之后shiftUp，再shiftDown ( 先shiftDown，再shiftUp也可以 )// for( int j = 1 ; j &lt;= count ; ++ j )// if( indexes[j] == i )&#123;// shiftUp( j );// shiftDown( j );// return;// &#125; int j = reverse[i]; shiftUp( j ); shiftDown( j ); &#125;&#125;;#endif //INDEXMINHEAP_INDEXMINHEAP_H]]></content>
    </entry>

    
  
  
</search>
