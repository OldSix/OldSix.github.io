<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Python2.7进阶 之 面向对象(3)]]></title>
      <url>%2F2017%2F04%2F09%2FPython2-7%E8%BF%9B%E9%98%B6-%E4%B9%8B-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-3%2F</url>
      <content type="text"><![CDATA[信仰是心中的绿洲，思想的骆驼队是永远走不到的。—— 纪伯伦 Python 元类metaclass 被称作是Python面向对象里最难理解, 也是最难使用的魔术代码. 正常情况下, 也不会碰到需要metaclass的情况. type()函数使用元类之前, 我们先来看看 type() 函数以及一些动态语言的特性. python作为动态语言与静态语言最大的不同, 就是函数和类的定义不是编译时定义的, 而是运行时动态创建的. 比如要定义一个Person的class, 就写一个 person_demo.py 的模块123class Person(object): def hello(self, name='world'): print 'Hello, &#123;&#125;'.format(name) 而type()函数的强大之处, 就在于既可以返回一个对象的类型, 又可以创建出新的类型, 而无需通过 class Person(object) .. 的定义:12345678910type(object) -&gt; the object's typetype(name, bases, dict) -&gt; a new typedef func(self, name='world'): print 'Hello, &#123;&#125;!'.format(name)Hello = type('Hello', (object,), dict(hello=func)) # 创建Hello classh = Hello()h.hello() # Hello, world! type()函数的三个参数: 要创建的class的名称 继承的父类的结合, 因为python中支持多继承, 单个父类, 记得要使用tuple单元素的写法 class的方法名称与函数绑定, 这里把func与成员方法hello绑定 通过type()函数创建的类与直接写class是完全一样的, 因为python解释器遇到class定义时, 底层也是调用type函数来进行创建class类型. metaclass除了使用type()函数动态创建类以外, 要控制类的创建行为, 还可以使用metaclass.简单的理解就是:先定义metaclass, 就可以创建类, 然后创建实例.或者说, 类就是metaclass创建出来的”实例”. 先看一个简单的例子1234567class ListMetaClass(type): # 元类的类名惯例上, 总是以metaclass结尾 def __new__(cls, name, bases, attrs): attrs['add'] = lambda self, value: self.append(value) # 向类中增加一个 add 方法 return type.__new__(cls, name, bases, attrs)class MyList(list): __metaclass__ = ListMetaClass # 指示使用ListMetaClass来定制类 在写下 __metaclass__ = ListMetaClass 语句时, 魔法就生效了, 它会指示python解释器, 在创建MyList时, 要通过ListMetaClass.new()来创建,我们可以修改类的定义, 比如加上新的方法, 然后, 返回修改后的定义 new()方法接收的参数依次是: 准备创建的类的对象 类的名字 类继承的父类集合 类的方法集合 这样的例子, 可能本身并没有什么实际的作用, 因为通过 metaclass 来添加一个方法, 实在太复杂, 不如简单类中自己定义一个方法就好了. 但是总会遇到需要通过 metaclass 来修改类定义的. 比如 ORM ORMORM 全称 “Object Relational Mapping”, 即对象关系映射, 就是把数据库关系的一行映射为一个对象, 也就是一个类对应一个表, 这样写代码更简单, 不用直接操作 SQL 语言. 期望达到这样的效果:123456789class User(Model): # 定义类属性到列的映射 id = IntegerField('id') name = StringField('username') email = StringField('email') password = StringField('password')u = User(id=12345, name='Six', email='zhiyupan.me', password='xxxx')u.save() 其中, 父类Model和属性类型StringField, IntegerField 是由 ORM框架提供的, 剩下的魔术方法 比如 save 全部由metaclass自动完成. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#!/usr/bin/env python# -*-coding: utf-8-*-class Field(object): def __init__(self, name, column_type): self.name = name self.column_type = column_type def __str__(self): return '&lt;&#123;&#125;:&#123;&#125;&gt;'.format(self.__class__.__name__, self.name)class StringField(Field): def __init__(self, name): super(StringField, self).__init__(name, 'varchar(100)')class IntegerField(Field): def __init__(self, name): super(IntegerField, self).__init__(name, 'bigint')################### ModelMetaclass #########################################class ModelMetaclass(type): def __new__(cls, name, bases, attrs): print name for k,v in attrs.iteritems(): print k,v print '*'*30 if name == 'Model': return type.__new__(cls, name, bases, attrs) mappings = dict() for k,v in attrs.iteritems(): print k, v print '='*20 if isinstance(v, Field): print 'Found mapping: &#123;&#125;==&gt;&#123;&#125;'.format(k,v) mappings[k] = v for k in mappings.iterkeys(): attrs.pop(k) attrs['__table__'] = name # 表名设置为类名 attrs['__mappings__'] = mappings # 保存属性和列的映射关系 return type.__new__(cls, name, bases, attrs)################### Model #########################################class Model(dict): __metaclass__ = ModelMetaclass # metaclass可以隐式地继承到子类 def __init__(self, **kw): super(Model, self).__init__(**kw) def __getattr__(self, key): print 'in Model.__getattr__: &#123;&#125;'.format(key) try: return self[key] except KeyError: raise AttributeError(r"'Model' object has no attribute '%s'"% key) def __setattr__(self, key, value): print 'in Model.__setattr__: &#123;&#125;: &#123;&#125;'.format(key, value) self[key] = value def save(self): fields = [] params = [] args = [] for k,v in self.__mappings__.iteritems(): print k print v fields.append(v.name) params.append('?') args.append(getattr(self, k, None)) sql = 'insert into %s (%s) values (%s)' % (self.__table__, ','.join(fields), ','.join(params)) print 'SQL: %s' % sql print 'ARGS: %s' % str(args)# 调用处class User(Model): id = IntegerField('id') name = StringField('name')u = User(id=1234, name='six')u.save() 大致的过程如下: python解释器遇到User类, 会优先在它的定义中查找是否存在__metaclass__, 如果没有, 就在它的父类中查找, 找到了, 就按照Model中定义的__metaclass__的ModelMetaclass来创建User类 ModelMetaclass中, 一共做了几件事: 排除对Model类的修改, 因为它是Model的基类 在当前类(比如User)中查找定义的类的所有属性, 如果找到一个Field属性, 那么保存在__mappings__的字典中, 同时从类属性中删除该属性, 否则会造成运行时错误 表名保存在__table__中, 默认为类名 注意: 观察User类本身, 其实添加的 id 和 name 都是User的类属性, 并且也并没有给出实例化 __init__ 方法 这2个类属性, 通过元类将其添加到 __mappings__ 中, 并且从类属性中剔除掉, 之后再从实例化对象时, 将属性传到实例属性处. 另外, Model基类本身是继承自 dict 基类, 通过 User(id=1234, name=six) 语句自动为实例对象, 添加了两个键值对, {id: 1234}, {name: six} 通过 metaclas 这样的设计, 使得ORM在使用起来, 异常简单明了.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python2.7进阶 之 面向对象(2)]]></title>
      <url>%2F2017%2F04%2F08%2FPython2-7%E8%BF%9B%E9%98%B6-%E4%B9%8B-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-2%2F</url>
      <content type="text"><![CDATA[谁不会休息，谁就不会工作。—— 列宁 Python 面向对象进阶 二getattr 和 methodcaller 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#!/usr/bin/env python# -*- coding: utf-8 -*-#__author__ = 'Six'' Test Module 'from operator import methodcallerclass Circle(object): def __init__(self, r): self.r = r def area(self): return self.r ** 2 * 3.14class Rectangle(object): def __init__(self, w, h): self.w = w self.h = h def get_area(self): return self.w * self.hclass Triangle(object): def __init__(self, a, b, c): self.a = a self.b = b self.c = c def getArea(self): a, b, c = self.a, self.b, self.c p = (a+b+c) / 2 area = (p*(p-a)*(p-b)*(p-c)) ** 0.5 return areadef getArea(shape): for name in ('area', 'getArea', 'get_area'): f = getattr(shape, name, None) if f: return f()def getArea2(shapes): res = [] for shape, name in zip(shapes, ('area', 'getArea', 'get_area')): res.append(methodcaller(name)(shape)) return resshape1 = Circle(2)shape2 = Triangle(3,4,5)shape3 = Rectangle(6,4)shapes = [shape1, shape2, shape3]print [getArea(s) for s in shapes]print getArea2(shapes) 使用descriptor对实例属性做类型检查包含有__get__ __set__ __delete__ 中的一个的类，就叫做描述符 在 __set__内使用instance函数做类型检查。 123456789101112131415161718192021222324252627282930313233#!/usr/bin/env python# -*- coding: utf-8 -*-#__author__ = 'Six'' Test Module 'class Attr(object): def __init__(self, name, type_): self.name = name self.type_ = type_ def __get__(self, instance, cls): return instance.__dict__[self.name] def __set__(self, instance, value): if not isinstance(self.name, self.type_): raise TypeError('expected an %s' % self.type_) instance.__dict__[self.name] = value def __delete__(self, instance): del instance.__dict__[self.name]class Person(object): name = Attr('name', str) age = Attr('age', int) height = Attr('height', float)p = Person()p.name = 'six' # ✅p.age = '17' # 错误 环状数据结构中管理内存python中是使用引用计数来管理内存，当引用计数为0时，对象才被析构 另外查看引用计数方法：12345import syssys.getrefcount(a) # 返回对象实际的引用计数个数 + 1，因为getrefcount方法本身也会持有a对象# 真实的引用次数sys.getrefcount(a) - 1 环状数据结构，两个对象彼此循环引用. 解决方案：使用标准库weakref，它可以创建一种能访问对象但不增加引用计数的对象 先看一个简单的例子： 12345678910111213class A(object): def __del__(self): print 'in A.__del__' a = A() # a的引用计数为1a2 = a # a的引用计数为2del adel a2 # 这时a才被析构# 如果使用weakref后a = A() # a的引用计数为1a_wref = weakref.ref(a)() # a的引用计数仍然为1del a # a立刻被析构 再看一个： 12345678910111213141516171819202122232425262728293031323334353637#!/usr/bin/env python# -*- coding: utf-8 -*-#__author__ = 'Six'' Test Module 'import weakrefclass Data(object): def __init__(self, value, owner): self.owner = weakref.ref(owner) # 得到一个弱引用的对象 self.value = value def __str__(self): # 注意：弱引用使用时，需要以函数调用的方式 return "%s's data, value is %s" % (self.owner(), self.value) def __del__(self): print 'in Data.__del__'class Node(object): def __init__(self, value): self.data = Data(value, self) def __del__(self): print 'in Node.__del__'node = Node(100)del node# import gc# gc.collect() # 强制回收垃圾内存，也不能解决循环引用的问题raw_input('wait...')]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python2.7进阶 之 面向对象(1)]]></title>
      <url>%2F2017%2F04%2F07%2FPython2-7%E8%BF%9B%E9%98%B6-%E4%B9%8B-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
      <content type="text"><![CDATA[躯体总是以惹人厌烦告终。除思想以外，没有什么优美和有意思的东西留下来，因为思想就是生命。—— 萧伯纳 Python 面向对象进阶港真, 想精通python, 没那么简单~ python越接触下来, 越觉得是一门使用简单, 但是设计感十足的语言. 原来一直以为python作为脚本语言, 应该是很简单, 很随意的语言,其实不然, 真正的想精通python, 还是有很大难度的. set &amp; get方法11234567891011121314151617181920212223242526#!/usr/bin/env python# -*- coding: utf-8 -*-__author__ = 'Six'' Test Module 'class Student(object): def __init__(self, name): self.__name = name def get_name(self): return self.__name def set_name(self, name): if isinstance(value, str): self.__name = value else: raise ValueError('Wrong Value Type') n = property(fget=get_name, fset=set_name)s = Student('six')s.n = 'six2017'print s.n # 'six2017' 方法2 1234567891011121314151617181920212223242526#!/usr/bin/env python# -*- coding: utf-8 -*-__author__ = 'Six'' Test Module 'class Student(object): def __init__(self, name): self.__name = name @property def name(self): return self.__name @name.setter def name(self, value): if isinstance(value, str): self.__name = value else: raise ValueError('Wrong Value Type')s = Student('six')s.name = 'six2017'print s.name # 'six2017' __new__ 和 __init__ 继承自object的新式类才有__new__ __new__至少要有一个参数cls，代表要实例化的类，此参数在实例化时由Python解释器自动提供 __new__必须要有返回值，返回实例化出来的实例，这点在自己实现__new__时要特别注意，可以return父类__new__出来的实例，或者直接是object的__new__出来的实例 __init__有一个参数self，就是这个__new__返回的实例，__init__在__new__的基础上可以完成一些其它初始化的动作，__init__不需要返回值 若__new__没有正确返回当前类cls的实例，那__init__是不会被调用的，即使是父类的实例也不行 1234567891011121314151617181920#!/usr/bin/env python# -*- coding: utf-8 -*-#__author__ = 'Six'' Test Module 'class IntTuple(tuple): def __new__(cls, iterable): g = (x for x in iterable if isinstance(x, int) and x &gt; 0) return super(IntTuple, cls).__new__(cls, g) def __init__(self, iterable): super(IntTuple, self).__init__(iterable)s = IntTuple([1, -1, 'abc', 6, ['x', 'y'], 3])print s # (1, 6, 3) __str__ 和 __repr__123456789101112class Student(object): def __init__(self, name): self.name = name def __str__(self): return 'Student: &#123;name&#125;'.format(name=self.name) __repr__ = __str__s = Student('six')print s # 'Student: six' __slots__限制class的属性，只允许对Student实例添加 __slots__ 中的属性因为在python中，是允许动态添加类属性的， 但是设置了__slots__后，不能再随意添加属性，也是一些常见python库中的使用的技巧之一__slots__ 还有一个重要用途：可以大幅度减少实例所占内存大小，主要减去了 __dict__ 的大小 1234567class Student(object): __slots__ = ('name','age') def __init__(self, name, age): self.name = name self.age = age 另外，查看对象的内存空间方法 import syssys.getsizeof(s.__dict__) 类属性不可变类型 123456789class Student(object): grade = 2016 def __init__(self, name, age): self.name = name self.age = ages = Student('six', 20)s.grade = 2017 # 增加了一个实例属性而已，类属性不会被修改print Student.grade # 仍然为2016 可变类型123456789class Student(object): grade = ['six', 2016] def __init__(self, name, age): self.name = name self.age = ages = Student('six', 20)s.grade[1] = 2017 # 对于可变类型而言，实例属性的修改将影响到类属性print Student.grade # ['six', 2017] 多态和继承12345678910111213141516171819202122232425262728293031323334353637#!/usr/bin/env python# -*- coding: utf-8 -*-#__author__ = 'Six'' Test Module 'class Animal(object): def __init__(self, name): self.name = name def run(self): print 'Animal: %s run...' % self.nameclass Dog(Animal): # 继承 def __init__(self, name, owner='six'): super(Dog, self).__init__(name) self.owner = owner def run(self): print 'Dog: %s run..., Owner is %s' % (self.name, self.owner) def run_twice(animal): animal.run() animal.run()def main(): a = Animal('ss') d = Dog('dd') # 多态 run_twice(a) run_twice(d)if __name__ == '__main__': main() 多继承 给一个类增加多个功能 1234567891011# 比如，编写一个多进程模式的TCP服务，定义如下：class MyTCPServer(TCPServer, ForkingMixin): pass# 编写一个多线程模式的UDP服务，定义如下：class MyUDPServer(UDPServer, ThreadingMixin): pass# 如果你打算搞一个更先进的协程模型，可以编写一个CoroutineMixin：class MyTCPServer(TCPServer, CoroutineMixin): pass staticmethod 和 classmethod12345678910111213141516171819202122232425#!/usr/bin/env python# -*- coding: utf-8 -*-#__author__ = 'Six'' Test Module 'class Student(object): grade = '2017' def __init__(self): self.name = 'six' def print(self): print 'I am &#123;&#125;'.format(self.name) @classmethod def get_grade(cls): return cls.grade @staticmethod def show(): print 'I am a Student' __call__12345678910class Student(object): def __init__(self, name): self.name = name def __call__(self): print('My name is %s.' % self.name)&gt;&gt;&gt; s = Student('Six')&gt;&gt;&gt; s()My name is Six.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Vim 总结]]></title>
      <url>%2F2017%2F04%2F06%2FVim-%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[Vim: 编译器之神Emacs: 神的编译器]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[STL基础 之 常用算法2]]></title>
      <url>%2F2017%2F04%2F05%2FSTL%E5%9F%BA%E7%A1%80-%E4%B9%8B-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%952%2F</url>
      <content type="text"><![CDATA[真理是时间的孩子，不是权威的孩子。—— 布莱希特 常用遍历算法: for_each(iterator_beg, iterator_end, _callback); 12_callback 可以是函数对象(最好是, 效率更高), 也可以是普通函数for_each的返回值是函数对象 transform(iterator_beg1, iterator_end1, iterator_beg2, _callback); transform(iterator_beg1, iterator_end1, iterator_beg2, iterator_dst_beg3, _callback);123将指定容器区间元素, 搬运到另一容器中.注意: transform不会给目标容器分配内存, 所以我们需要提前分配好内存.transform的返回值是目标容器的迭代器. 常用查找算法: find(iterator_beg, iterator_end, value) 1find的返回值, 返回查找元素位置, 查找不到返回 iterator.end() find_if(iterator_beg, iterator_end, _callback); adjacent_find(iterator_beg, iterator_end, _callback); 1查找相邻重复的元素 bool binary_search(iterator_beg, iterator_end, value); count(iterator_beg, iterator_end, value); 12统计元素出现的次数返回元素的个数 count_if(iterator_beg, iterator_end, value); 常用排序算法 merge(iterator_beg1, iterator_end1, iterator_beg2, _iterator_end2, iterator_dst_begin); sort(iterator_beg, iterator_end, _callback); random_shuffle(iterator_beg, iterator_end); 1随机调整范围内元素的次序. reverse(iterator_beg, iterator_end); 1逆序排列范围内的顺序. 常用拷贝和替换算法 copy(iterator_beg, iterator_end, iterator_dst); replace(iterator_beg, iterator_end, oldvalue, newvalue); replace_if(iterator_beg, iterator_end, _callback, newvalue); swap(container c1, container c2); 常用算数生成算法 accumulate(iterator_beg, iterator_end, value); 1累计范围内元素的总和 fill(iterator_beg, iterator_end, value); 1向容器范围内添加元素 常用集合算法 set_intersection(iterator_beg1, iterator_end1, iterator_beg2, iterator_end2, iterator_dst_beg); 1求两个set集合的交集 set_union(iterator_beg1, iterator_end1, iterator_beg2, iterator_end2, iterator_dst_2); 1求两个set集合的合集 set_difference(iterator_beg1, iterator_end1, iterator_beg2, iterator_end2, iterator_dst_2) 1求两个set集合的差集]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[STL基础 之 常用算法1]]></title>
      <url>%2F2017%2F04%2F04%2FSTL%E5%9F%BA%E7%A1%80-%E4%B9%8B-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%2F</url>
      <content type="text"><![CDATA[理想对我来说，具有一种非凡的魅力。我的理想总是充满着生活和泥土气息。我从来都不去空想那些不可能实现的事情。—— 奥斯特洛夫斯基 算法头文件是由 “ algorithm functional numeric “ 组成. algorithm 是所有STL头文件中最大的一个, 其中常用的功能涉及到比较, 交换, 查找遍历,复制, 修改, 反转, 排序, 合并等.. numeric 体积很小, 只包括几个序列容器上进行的简单运算的模板函数. functional 定义了一些模板类, 用以声明函数对象. 1. 函数对象重载函数调用操作符的类, 其对象常称为函数对象, 即它们是行为类似函数的对象, 也叫仿函数.其实就是重载了 “( )” 操作符, 使得类对象可以像函数那样调用. 注意:123456789101112131415161. 函数对象(仿函数)是一个类, 不是一个函数2. 函数对象重载了&quot;()&quot;操作符, 使得它可以像函数一样调用3. 函数对象可以像普通函数一样调用, 并且可以有参数, 有返回值4. 函数对象也可以做参数5. 函数对象可以有自己的状态6. 函数对象比普通函数执行效率高, 有一定就几率在类内部被内联编译struct Print&#123; void operator( int val )&#123; cout&lt;&lt;val&lt;&lt;endl; &#125;&#125;;void doBusiness(Print p)&#123; p(20);&#125; 分类 一元仿函数(一个参数) 和 二元仿函数(两个参数) 2. 谓词谓词是指 普通函数或者重载的operator() 返回值是 bool类型的函数对象(仿函数).如果operator接收一个参数, 那么叫做一元谓词; 如果接收两个参数, 那么叫做二元谓词. 谓词可以作为一个判断式. 一元谓词12345678910111213141516171819struct GreaterThanFive&#123; bool operator()(int val)&#123; return val &gt; 5; &#125;&#125;void test1()&#123; vector&lt;int&gt; v; for( int i = 0 ; i &lt; 10 ; ++i )&#123; v.push_back(i); &#125; vector&lt;int&gt;::iterator ret = find_if(v.begin(), v.end(), GreaterThanFive()); if( ret == v.end() )&#123; cout &lt;&lt; "NOT FOUND!" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "FOUND IT: " &lt;&lt; *it &lt;&lt; endl; &#125;&#125; 二元谓词1234567891011121314151617181920212223struct MyCompare&#123; bool operator()(int v1, int v2)&#123; return v1 &gt; v2; &#125;&#125;;void test02()&#123; vector&lt;int&gt; v; srand((unsigned int)time(NULL)); for( int i = 0 ; i &lt; 10 ; ++i ) v.push_back(rand()%100); for( vector&lt;int&gt;::iterator it = v.begin() ; it != v.end() ; ++it ) cout&lt;&lt;*it&lt;&lt;" "; cout&lt;&lt;endl; // 排序算法 sort( v.begin() , v.end() , MyCompare ); for( vector&lt;int&gt;::iterator it = v.begin() ; it != v.end() ; ++it ) cout&lt;&lt;*it&lt;&lt;" "; cout&lt;&lt;endl;&#125; 3. 内建函数对象STL内建了一些函数对象, 分为: 算数类函数对象, 关系运算类函数对象, 逻辑运算类函数对象.引入头文件 #include 算数类函数对象123456template &lt;class T&gt; T plus&lt;T&gt;;template &lt;class T&gt; T minus&lt;T&gt;;template &lt;class T&gt; T multiplies&lt;T&gt;;template &lt;class T&gt; T divieds&lt;T&gt;;template &lt;class T&gt; T modulus&lt;T&gt;;template &lt;class T&gt; T negate&lt;T&gt;;// 一元 关系运算类函数对象, 都是二元运算123456template &lt;class T&gt; bool equal_to(T);template &lt;class T&gt; bool not_equal_to(T);template &lt;class T&gt; bool greater(T);template &lt;class T&gt; bool greater_equal(T);template &lt;class T&gt; bool less(T);template &lt;class T&gt; bool less_equal(T); 逻辑运算类函数对象123template &lt;class T&gt; bool logical_and(T);template &lt;class T&gt; bool logical_or(T);template &lt;class T&gt; bool logical_not(T);// 一元 比如123456789vector&lt;int&gt; v;v.push_back(2);v.push_back(1);v.push_back(6);v.push_back(5);v.push_back(9);sort( v.begin() , v.end() , greater&lt;int&gt;() );for_each( v.begin() , v.end() , []( int val )&#123; cout&lt;&lt;val&lt;&lt;" "&#125;); 4. 适配器绑定适配器123456789101112131415161718192021#include &lt;functional&gt;struct MyPrint : public binary_function&lt;int, int, void&gt; &#123; void operator()(int v1, int v2) const &#123; cout &lt;&lt; v1 &lt;&lt; " " &lt;&lt; v2 &lt;&lt; endl; &#125;&#125;;void test()&#123; vector&lt;int&gt; v; v.push_back(10); v.push_back(20); v.push_back(30); v.push_back(40); v.push_back(50); // bind2nd 把二元函数对象适配成一元函数对象 // 也可以用bind1st, 本质没有任何区别, 就是附属参数的位置 // 函数对象才可以, 普通函数使用bind会报错 for_each(v.begin(), v.end(), bind2nd(MyPrint(), 100));&#125; 函数指针适配器1234567891011121314151617#include &lt;functional&gt;void MyPrintFunction()(int v1, int v2) const &#123; cout &lt;&lt; v1 &lt;&lt; " " &lt;&lt; v2 &lt;&lt; endl;&#125;void test()&#123; vector&lt;int&gt; v; v.push_back(10); v.push_back(20); v.push_back(30); v.push_back(40); v.push_back(50); // ptr_func 把普通函数转换为函数对象(仿函数) for_each(v.begin(), v.end(), bind2nd(ptr_func(MyPrintFunction), 100));&#125; 取反适配器1234567891011121314151617181920212223242526272829// not1 (针对一元函数对象取反)struct myCondition : public unary_function&lt;int, bool&gt; &#123; bool operator()(int v) const &#123;// const 必须要加 return v &gt;= 20; &#125;&#125;;void test()&#123; vector&lt;int&gt; v; v.push_back(10); v.push_back(20); v.push_back(30); v.push_back(40); v.push_back(50); // not1(函数对象), 对函数对象对应的结果取反 vector&lt;int&gt;::iterator it = find_if(v.begin(), v.end(), not1(myCondition())); if (it == v.end())&#123; cout &lt;&lt; "NOT FOUND" &lt;&lt; endl; &#125; else &#123;// 找到的是小于20的数 cout &lt;&lt; "Found: " &lt;&lt; *it &lt;&lt; endl; &#125; // not2 (针对二元函数对象取反) // 结果从大到小输出 sort(v.begin(), v.end(), not2(less&lt;int&gt;()));&#125; 成员函数适配器: 将类中的成员函数适配成函数对象123456789101112131415161718192021222324252627282930313233343536373839404142class Student&#123;public: Student(string name, int age) : name(name), age(age)&#123;&#125; void print()&#123; cout &lt;&lt; "name: " &lt;&lt; name &lt;&lt; "age: " &lt;&lt; age &lt;&lt; endl; &#125;private: string name; int age;&#125;;void test()&#123; vector&lt;Student *&gt; v; Student *s1 = new Student("stu1", 10); Student *s2 = new Student("stu2", 20); Student *s3 = new Student("stu3", 30); Student *s4 = new Student("stu4", 40); Student *s5 = new Student("stu5", 50); v.push_back(s1); v.push_back(s2); v.push_back(s3); v.push_back(s4); v.push_back(s5); // mem_func : 如果存储的是对象的指针, 需要使用mem_func for_each(v.begin(), v.end(), mem_func(&amp;Student::print)); cout &lt;&lt; "---------------" &lt;&lt; endl; vector&lt;Student&gt; v2; v2.push_back(Student("stu1", 10)); v2.push_back(Student("stu2", 20)); v2.push_back(Student("stu3", 30)); v2.push_back(Student("stu4", 40)); v2.push_back(Student("stu5", 50)); // mem_func : 如果存储的是对象本身, 需要使用mem_func_ref for_each(v2.begin(), v2.end(), mem_func_ref(&amp;Student::print));&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[STL基础 之 关联容器]]></title>
      <url>%2F2017%2F04%2F04%2FSTL%E5%9F%BA%E7%A1%80-%E4%B9%8B-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%2F</url>
      <content type="text"><![CDATA[青春留不住，白发自然生。—— 杜牧 关联式容器 – set &amp; map. set &amp; multiset1. 基本概念set的特性是: 所有特性都会根据元素的键值自动被排序. set不允许两个元素有相同的键值. 迭代器: set的迭代器是一种const_iterator. 也就是说, 不能根据set的迭代器改变set元素的值. multiset特性与set基本一致, 唯一的差别是它允许键值重复. set和multiset的底层实现是红黑树, 是平衡二叉树的一种, 是一种高级数据结构. 2. set常用APIset 构造函数 123set&lt;T&gt; st;multiset&lt;T&gt; mst;set(const set &amp;st); set 赋值函数12set&amp; operator=(const set &amp;st);swap(st); set 大小操作12size()empty() set 插入和删除12345insert(elem);clear();erase(pos);erase(beg, end);erase(elem); set 查找操作12345find(key);count(key);lower_bound(keyElem);upper_bound(keyElem);equal_range(keyElem); set 的返回值和指定set排序规则123456789101112131415struct MyCompare02&#123; bool operator()(int v1, int v2)&#123; return v1 &gt; v2; &#125;&#125;;srand((unsigned int)time(NULL));set&lt;int, MyCompare02&gt; s;for( int i = 0 ; i &lt; 10 ; ++i )&#123; s.insert(rand()%100);&#125;for( set&lt;int, MyCompare02&gt;::iterator it = s.begin() ; it != s.end() ; ++it )&#123; cout &lt;&lt; *it &lt;&lt; " ";&#125;cout &lt;&lt; endl; pair对组 1234567891011121314// 第一种pair&lt;string, int&gt; pair1(string("name"), 20);cout &lt;&lt; pair1.first &lt;&lt; endl;cout &lt;&lt; pair1.second &lt;&lt; endl;// 第二种pair&lt;string, int&gt; pair2 = make_pair("name", 30);cout &lt;&lt; pair2.first &lt;&lt; endl;cout &lt;&lt; pair2.second &lt;&lt; endl;// 赋值pair&lt;string, int&gt; pair3 = pair2;cout &lt;&lt; pair3.first &lt;&lt; endl;cout &lt;&lt; pair3.second &lt;&lt; endl; map/multimap1. 基本概念map的特性是, 所有元素都会根据元素的键值自动排序. map的所有元素都是pair, 同时拥有实值和键值, pair的第一个元素是键值, pair的第二个元素被视为实值, map不允许两个元素有相同的键值. 迭代器: 不能通过map的迭代器改变map的键值. multimap和map操作一致, 唯一区别是multimap键值可重复.multimap和map都是以红黑树为底层实现机制的. 2. map/multimap 常用API构造函数12map&lt;T1, T2&gt; maptt;map(const map&amp; mp); 赋值函数12map&amp; operator=(const map&amp; mp);swap(mp); map大小操作12size();map(); map插入数据123456789map.insert(...);map&lt;int, string&gt; mapStu;mapStu.insert(pair&lt;int, string&gt;(3, "小张"));mapStu.insert(make_pair(-1, "校长"));mapStu.insert(map&lt;int, string&gt;::value_type(1, "小李"));mapStu[3] = "小刘";mapStu[5] = "小王"; map删除操作1234clear();erase();erase(beg, end);erase(elem); map查找操作12345find(key);count(keyElem);lower_bound(keyElem);upper_bound(keyElem);equal_range(keyElem); STL容器元素深/浅拷贝问题stl容器所提供的都是值寓意, 而非引用寓意, 也就是说当我们往容器中插入元素的时候, 容器内部实施了拷贝动作,将我们插入的元素再另行拷贝一份放入容器中, 而不是将原数据元素直接放进容器中, 也就是我们提供的元素必须能够被拷贝. STL容器使用时机 vector的使用场景 比如软件历史操作记录的存储, 我们经常要查看历史记录, 而不会去删除记录. deque的使用场景 排队购票系统, 支持头端的快速移除, 尾端的快速添加. vector 与 deque 的比较: vector.at() 比 deque.at()效率高 如果有大量释放操作, vector花的时间更少 deque支持头部的快速插入与快速移除, 这是deque的优点 list使用场景 公交车乘客的存储, 随时可能有乘客下车, 支持频繁的不确定位置元素的移除插入. set使用场景 手机游戏的个人得分纪录, 存储要求从高到低顺序排列 map的使用场景 按ID号存储10万用户, 想要快速通过ID查找到对应的用户.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[STL基础 之 序列容器]]></title>
      <url>%2F2017%2F04%2F03%2FSTL%E5%9F%BA%E7%A1%80-%E4%B8%80%2F</url>
      <content type="text"><![CDATA[现实是此岸，理想是彼岸，中间隔着湍急的河流，行动则是架在河上的桥梁。—— 克雷洛夫 STL( Standard Template Library , 标准模板库 ), 是惠普实验室开发的一系列软件的统称, 现在主要出现在C++中. 1 STL六大组件: 容器 算法 迭代器 仿函数 适配器 空间配置器 2 算法 分类: 质变算法和非质变算法 质变算法: 拷贝, 替换, 删除.. 非质变算法: 查找, 计数, 遍历, 寻找极值.. 3 迭代器 种类: 输入迭代器 - 只读访问, 支持++, ==, != 输出迭代器 - 只写, 支持++ 前向迭代器 - 读写, 支持++, ==, != 双向迭代器 - 读写, 支持++, -- 随机访问迭代器 - 读写, 支持++, --, [n], -n, &lt;, &lt;=, &gt;, &gt;= STL概述STL优点 高可复用性 高性能 高移植性 STL中心思想 将数据容器和算法分开, 彼此独立设计 常见序列式容器1 Vector动态数组迭代器: 随机访问迭代器 构造函数 12345678vector&lt;T&gt; v;vector&lt;v.begin(), v.end());vector&lt;n, elem);vector&lt;const vector &amp;vec);// e.g.int arr[] = &#123;2,3,4,1,9&#125;;vector&lt;int&gt; v1(arr, arr+sizeof(arr)/sizeof(int)); 赋值 1vector&amp; operator=(const vector &amp;vec); 大小操作 123456size();empty();resize(int num);resize(int num, elem);capacity();reserve(int len); 数据存取操作 1234at(int idx)operator[];front();back(); 插入和删除 123456insert(const iterator pos, int count, ele);push_back(elem);pop_back();erase(const iterator start, const iterator end);erase(const iterator pos);clear(); vector 小坑与小技巧 当vector不停的插入元素的时, size不断的增大的同时, 他的容量其实也被扩充上去了. 12345v.clear();// 只能清除size, 内存的大小还在vector&lt;int&gt;().swap(v);// 创建一个匿名对象, 与v的内存空间进行交换, 匿名对象在第二行生命周期结束, 将内存释放掉, v的内存空间变成一个对象的内存空间v.reserve();// 预先开辟空间 2 Deque双向开口的连续线性空间, 头尾都可以进行插入和删除.一段一段的定量的连续空间构成 – 中控器和缓冲区, 数据结构相比vector复杂 迭代器方面: 随机访问迭代器. 构造函数 1234deque&lt;T&gt;;deque(beg, end);deque(n, elem);deque(const deque &amp;deq); 赋值 12deque&amp; operator=(const deque &amp;deq);swap(deq); 大小操作 1234deque.size();deque.empty();deque.resize(num);deque.resuze(num, elem); deque双端插入和删除操作 1234push_back();push_front();pop_back();pop_front(); deque存取操作 1234at(idx)operator[];front();back(); deque插入操作 123insert(pos, elem);insert(pos, n, elem);insert(pos, beg, end); deque删除操作 123clear();erase(beg, end);erase(pos); 总结: 因为deque设计的特殊性, 其复杂程度远超vector, 当然也影响到各个运算的层面.因此除非有必要, 否则应该尽可能的使用vector, 而不是deque. 最后, 对deque的排序操作, 为了最高效率, 可以将deque先完整的复制到一个vector中, 对vector进行排序后, 再复制回的deque. 3 List循环双向链表. vector 和 list 是最常被使用的两个容器.list对空间的运用有绝对的精准, 动态存储分配, 一点都不浪费.插入和删除操作十分方便, 修改指针即可.但是, 空间和时间消耗比较大. 迭代器: 双向迭代器 List的重要性质: 插入和删除操作都不会造成对原有list迭代器的失效. vector就行, 一旦涉及到重新分配内存, 原有的迭代器地址就会失效. 构造函数 1234list&lt;T&gt; lst;list(beg, end);list(n, elem);list(const list &amp;lst); 插入和删除 1234567891011push_back(elem);pop_back();push_front();pop_front();insert(pos, elem);insert(pos, n, elem);insert(pos, beg, end);clear();erase(beg, end);erase(pos);remove(elem); 大小操作 1234size();empty();resize(num);resize(num, elem); 赋值 12list&amp; operator=(const list&amp; lst);swap(lst); 存取 12front();back(); 排序 12reverse();sort(); 4 Stack先进后出, 只有一个出口. 迭代器: stack没有迭代器. 也不提供遍历功能. 构造函数 12stack&lt;T&gt; sk;stack(const stack&amp; stk); 赋值 1234stack&amp; operator=(const stack &amp;stk);push(elem);pop();top(); 大小操作 12empty();size(); 5 Queue队列, 先进先出. 迭代器: 不提供遍历功能, 也不提供迭代器. 构造函数 12queue&lt;T&gt; que;queue(const queue&amp; que); 存取, 插入和删除 1234push(elem);pop();back();front(); 赋值1queue&amp; operator=(const queue &amp;que); 大小操作12empty();size();]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python2.7 基础知识(一)]]></title>
      <url>%2F2017%2F04%2F03%2FPython2-7-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E4%B8%80%2F</url>
      <content type="text"><![CDATA[道德普遍地被认为是人类的最高目的，因此也是教育的最高目的.—— 赫尔巴特 Python2.7基础（一）拿什么写python（1） python官方IDE（2） ipython（3） sublime text（4） Atom 1 输入输出输入： print ‘hello world’ 输出： name = raw_input(‘Please enter your name: ‘)raw_input 返回值为字符串 2 数据类型和变量可变类型： 1# 列表 不可变类型： 12345# 整数# 浮点数# 字符串# 布尔值# 空值 None python中的变量，都是一个对象，对于不可变类型数据来说，变量看似是变成了一个新值， 但是其实是指向了一个新的对象而已，多个变量指向同一个对象时，对象不会被重复创建，只是引用计数器+1 1234567891011a = 10b = aa = 20# b = ?# 有c语言基础的同学，其实可以将python中的赋值操作，理解为指针操作。a = 10 # 其实是指 变量a 指向了 10 这个数据b = a # 变量b 此时也指向了 10 这个数据， 此时有2个变量指向 10a = 20 # 变量a 此时指向了20， 并不是把 10 这个数据修改了b = 10 # 此时b 仍为10 python中，字符串和整数都被缓存起来了，并不会重复创建，也不会被销毁 3 字符串和编码4 list, tuple 和 dict, setdir(list) ==&gt; 查看对象属性 list1234567891011121314151617a = [1, 2, 3]a.append(4)a.count(value)a.extend()a.index(value)a.pop()a.remove()a.reverse()a.sort() tuple123a = (1, 2, 3)a.count(value)a.index(value) dict123456789101112131415161718clearcopyfromkeysgethas_keyitemsiteritemsiterkeysitervalueskeyspoppopitemsetdefaultupdatevaluesviewitemsviewkeysviewvalues set1234567891011121314151617addclearcopydifferencedifference_updatediscardintersectionintersection_updateisdisjointissubsetissupersetpopremovesysmmetric_differencesysmmetric_difference_updateunionupdate 5 函数函数变长参数: args 和 *kwargs 也叫包裹传递 123456789def test_func(a, b, *args, **kwargs): passtest_ func(1,2,3,4, x=100, y=200)# a = 1# b = 2# args = (3,4)# kwargs = &#123;'x': 100, 'y': 200&#125; 解包裹, 将整体传入的参数, 拆分12345678def func(a,b,c): print a,b,cargs = (1,3,4)func(*args) # 1,3,4dict = &#123;'a':1,'b':2,'c':3&#125;func(**dict) # 1,2,3 6 高级特性切片：123a_list[::-1] # 逆序a_list[:] # 拷贝， 浅拷贝a_list[::2] # 隔一个取一个 浅拷贝：123456alist[:] # 切片拷贝list(alist) # list工厂方法import copycopy.copy(alist) # copy方法 深拷贝：12import copycopy.deepcopy(alist) zip1234a = (1,2,3)b = (4,5,6)[(x,y) for x,y in zip(a, b)][(1,4),(2,5),(3,6)] enumerate1234for i, e in enumerate(a): print i, e# i 为index# e 为元素 Iterable123from collections import Iterableisinstance(a, Iterable)&gt;&gt;&gt; True 列表生成器： 12345[randint(0,100) for _ in xrange(10)][x**2 for x in xrange(10)][x for x in xrange(10) if x%2] 生成器： 1234567891011121314151617181920212223# 基础用法(randint(0,100) for _ in xrange(10))(x**2 for x in xrange(10))(x for x in xrange(10) if x%2)# next() , send()next 获取迭代器中的下一个值, 直到获取完毕send 具有next的全部功能之外, 还可以传递参数# yielddef gen(): for x in xrange(4): temp = yield x if temp == 'hello': print 'world' else: print 'haha', tempyield作用: - 中断函数, 返回x的值 - 再次运行时, 可以再次回到上次中断的位置, 继续向下执行 7 函数式编程map / reduce1234567891011121314map(lambda x: x**2, a)map中传入的函数, 要求传入一个参数, 也就是seq中的每一个元素.map的返回值, 就是每个元素经过函数处理之后的新值, 并将新值放入了一个新的seq, 然后返回seq-----------------reduce(lambda x,y: x+y, a)reduce中传入的函数, 要求传入两个参数,参数来源也就是seq中的元素reduce函数的作用就是, 将seq中从前往后, 前2个元素进行一次操作, 操作后的结果, 再跟下一个元素进行运算, 直到最后.reduce的返回值, 返回一个运算后的结果 filter12345filter(lambda x:x%2, a)filter中也要求传入一个函数, 要求传入一个参数, 也就是seq中的元素, 但是要求函数的返回值必须是布尔类型根据返回值的True或False, False时移除该元素 sorted1sorted 返回一个新的list 匿名函数1lambda x, y: x*y 装饰器 123456789101112131415161718192021222324252627282930313233343536373839from time import timeimport functoolsdef logged(when=''): def log(f, *args, **kwargs): print f, args, kwargs def pre_logged(f): @functools.wraps(f) def wrapper(*args, **kwargs): log(f, *args, **kwargs) f(*args, **kwargs) print 'pre_logged' return wrapper def post_logged(f): @functools.wraps(f) def wrapper(*args, **kwargs): now = time() try: return f(*args, **kwargs) finally: log(f, *args, **kwargs) print 'time delta: %s' % (time()-now()) return wrapper try: if when: return &#123;'pre': pre_logged, 'post': post_logged&#125;[when] else: return pre_logged except: ValueError('must be "pre" or "post" %s' % e)@logged("post")def func(name): # 如果不引入functools模块, func函数被装饰器函数包裹后, __name__ 变成了 wrapper print '---&gt;Hello %s, %s' % (name, __name__) 偏函数12345# 通过设定参数的默认值，可以降低函数调用的难度.import functoolsint2 = functools.partial(int, base=8) 8 模块123456789101112131415161718192021#!/usr/bin/env python# -*- coding: utf-8 -*-' a test module '__author__ = 'Six'import sysdef test(): args = sys.argv if len(args)==1: print 'Hello, World!' elif len(args)==2: print 'Hello, %s!' % args[1] else: print 'Too many arguments!'if __name__=='__main__': # 模块内部的调试代码, 被导入时, name == 模块名, 自己运行时, name 才等于 __main__ test() 包: 1文件夹内, 加入 __init__.py, 模块升级为包 _future模块12from __future__ import unicode_literalsfrom __future__ import division]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[C++模板原理简单剖析]]></title>
      <url>%2F2017%2F04%2F02%2FC-%E6%A8%A1%E6%9D%BF%E5%8E%9F%E7%90%86%E7%AE%80%E5%8D%95%E5%89%96%E6%9E%90%2F</url>
      <content type="text"><![CDATA[真正的自由属于那些自食其力的人，并且在自己的工作中有所作为的人。—— 罗·科林伍德 c++提供了两种机制: 函数模板 和 类模板. 总结: (1) 模板把函数或类要处理的数据类型参数化, 表现为参数的多态性, 成为类属, 又称参数模板(2) 模板用于表达逻辑结构相同, 但具体数据元素类型不同的数据对象的通用行为(3) 用模板实现泛型, 可以减轻编程的工作量, 增强函数的重用性 函数模板简单使用 123456789101112131415161718192021template&lt;typename T&gt;void mySwap(T&amp; a, T&amp; b)&#123; T temp = a; a = b; b = temp;&#125;void test()&#123; int a = 10; int b = 20; // 函数模板可以自动推导参数类型 --&gt; int mySwap(a,b); char c1 = 'a'; char c2 = 'b'; // 函数模板可以自动类型推导, 也可以显示指定类型 mySwap&lt;char&gt;(c1,c2);&#125; 函数模板和普通函数的区别 函数模板不允许自动化类型转化, 必须严格匹配类型, 也就是不允许隐式转换, 比如 char 转 int ; 普通函数可以自动转换; 函数模板和普通函数的调用规则 函数模板可以像普通函数那样被重载 都能匹配的话, c++编译器优先考虑普通函数 如果函数模板可以产生一个更好的匹配(比如不需要隐式类型转换), 那么选择模板 可以通过空模板实参列表的语法, 限定编译器只能通过模板匹配 myPlus&lt;&gt;(a, b) 类模板 类模板用于实现类所需数据的类型参数化 类模板在表示如数组, 表, 图等数据结构显得特别重要, 这些数据结构的表示和算法不受所包含的数据类型的影响. 12345678910111213141516171819202122template&lt;class NameType, class AgeType&gt;class Person&#123;public: Person(NameType name, AgeTye age)&#123; this-&gt;mName = name; this-&gt;mAge = age; &#125; void PrintPerson()&#123; cout &lt;&lt; "Name: " &lt;&lt; this-&gt;mName &lt;&lt; endl; &#125;public: NameType mName; AgeType mAge;&#125;;void test()&#123; Person&lt;string, int&gt; p("John", 30); p.PrintPerson(); return;&#125; 类模板做函数参数1234567891011121314151617// 1template &lt;class T&gt;void doBusiness(T&amp; p)&#123; p.mAge += 20; p.mName += "vip"; p.PrintPerson();&#125;// 2template &lt;class T1, class T2&gt;void doBusiness(Person&lt;T1, T2&gt;&amp; p)&#123; p.mAge += 20; p.mName += "vip"; p.PrintPerson();&#125; 类模板派生普通类子类实例化的时候, 需要具体化的父类, 这样c++编译器才能知道给子类分配多少内存 12345678class SubClass: public MyClass&lt;int&gt;&#123;public: SubClass(int b): MyClass&lt;int&gt;(20)&#123; this-&gt;mB = b; &#125;public: int mB;&#125; 类模板派生类模板12345678910111213141516171819template &lt;class T&gt;class MyClass&#123;public: MyClass(T property)&#123; this-&gt;mProperty = property; &#125;public: T mProperty;&#125;template &lt;class T&gt;class SubClass : public MyClass&lt;T&gt;&#123;public: SubClass(T b) : MyClass&lt;T&gt;(b) &#123; this-&gt;mB = b; &#125;public: T mB;&#125; 类模板碰上友元函数按照常规, 在类外实现 12345678910111213141516171819202122232425template&lt;class T&gt;class Person&#123; // 首先, 编译器紧把这个友元函数, 当作是一个普通函数, 不会根据具体类型, 去产生具体的实现体, 即使外部给出了函数模板实现体 // 其次, 友元函数其实并不是函数声明, 只是告诉编译器, 这个函数是我的一个朋友, 仅此而已. 并没有对实现进行检查, 所以调用时, 编译器根本不知道有这样一个函数声明 // 外部调用时, 会直接当成普通函数, 去查找其实现体, 而类外的实现仅是为函数模板生成具体实现, 普通函数不会为其实现 // 所以, 会直接产生错误, 找不到函数的声明和实现 friend void FriendPerson(Person&lt;T&gt; &amp;p);public: Person(T p)&#123; this-&gt;mProperty = p; &#125;private: T mProperty;&#125;;template&lt;class T&gt;void FriendPerson(Person&lt;T&gt; &amp;p)&#123; cout &lt;&lt; p.mProperty &lt;&lt; endl;&#125;void test()&#123; Person&lt;int&gt; p (20); Friend(p);// 错误, 没有声明, 也没有实现&#125; 修改为, 两步: 告诉编译这个友元函数要优先匹配函数模板, 不要先找普通函数 需要给出友元函数的函数声明, 因为类内的friend仅是一个标识, 告诉编译器这个函数是我哥们, 可以访问所有私有数据 1234567891011121314template &lt;class T&gt; class Person; // person类前向声明template &lt;class T&gt; void FriendPerson(Person&lt;T&gt; &amp;person);template&lt;class T&gt;class Person&#123; // 要修改为匹配模板调用 friend void FriendPerson&lt;&gt;(Person&lt;T&gt; &amp;p);public: Person(T p)&#123; this-&gt;mProperty = p; &#125;private: T mProperty;&#125;; 改成友元函数模板声明, 最终版: 1234567891011template&lt;class T&gt;class Person&#123; // 将friend方法声明为函数模板, 其他不变, 编译通过, 运行无误 template&lt;class T2&gt; friend void FriendPerson(Person&lt;T2&gt; &amp;p);public: Person(T p)&#123; this-&gt;mProperty = p; &#125;private: T mProperty;&#125;; 总结: 如果是类内实现友元函数的话, 友元的类名声明, 可以不加template标识, 建议这样来写, 简单方便. 如果类外实现的话, 友元的类内声明, 一定要加template标识, 否则就要friend处标识匹配模板实现, 另外还有额外声明友元函数, 可能还要进行前置声明. 模板机制剖析或者说, 模板为什么不能跨文件编写? 原因一: 编译器的独立编译原则 编译当前文件时, 不关心也不知道, 另一个文件的情况 比如, 当前文件调用了另一个文件的方法, 但是编译到当前文件时, 并不关心这个方法是否真的实现, 或者实现中有什么错误, 只是单纯的认为, 存在的就是对的. 如果没有实现, 那么交给链接时, 再去报错. 原因二: 模板的二次编译 编译器会对模板进行两次编译, 在声明的地方对模板代码本身进行编译, 在调用的地方对参数替换后的代码进行编译. 模板, 其实也是c++编译器做的众多小动作中一个而已.语法上提供了一些简便的写法–写入一个typename即可替代所有类型. 真正的底层原因就是二次编译, 模板还是模板, 但是在其被真正使用或调用的那一刻, 那么编译器就会为它具体生成一个具体的类型实现. 但是问题来了, 如果分开文件实现, 那么在实现文件中, 由于编译器的单独编译特性, 所以编译到实现文件时, 并不知道当前模板被调用的情况, 因为调用通常是在其他文件. 在模板不知道自己被调用时, 编译器不会为其生成具体的实现, 所以模板调用处, 才产生链接错误, 方法找不到实现.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[C++模板原理简单剖析]]></title>
      <url>%2F2017%2F03%2F24%2F%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1-%E4%B9%8B-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%2F</url>
      <content type="text"><![CDATA[真正的自由属于那些自食其力的人，并且在自己的工作中有所作为的人。—— 罗·科林伍德 c++提供了两种机制: 函数模板 和 类模板. 总结: (1) 模板把函数或类要处理的数据类型参数化, 表现为参数的多态性, 成为类属, 又称参数模板(2) 模板用于表达逻辑结构相同, 但具体数据元素类型不同的数据对象的通用行为(3) 用模板实现泛型, 可以减轻编程的工作量, 增强函数的重用性 函数模板简单使用 123456789101112131415161718192021template&lt;typename T&gt;void mySwap(T&amp; a, T&amp; b)&#123; T temp = a; a = b; b = temp;&#125;void test()&#123; int a = 10; int b = 20; // 函数模板可以自动推导参数类型 --&gt; int mySwap(a,b); char c1 = 'a'; char c2 = 'b'; // 函数模板可以自动类型推导, 也可以显示指定类型 mySwap&lt;char&gt;(c1,c2);&#125; 函数模板和普通函数的区别 函数模板不允许自动化类型转化, 必须严格匹配类型, 也就是不允许隐式转换, 比如 char 转 int ; 普通函数可以自动转换; 函数模板和普通函数的调用规则 函数模板可以像普通函数那样被重载 都能匹配的话, c++编译器优先考虑普通函数 如果函数模板可以产生一个更好的匹配(比如不需要隐式类型转换), 那么选择模板 可以通过空模板实参列表的语法, 限定编译器只能通过模板匹配 myPlus&lt;&gt;(a, b) 类模板 类模板用于实现类所需数据的类型参数化 类模板在表示如数组, 表, 图等数据结构显得特别重要, 这些数据结构的表示和算法不受所包含的数据类型的影响. 12345678910111213141516171819202122template&lt;class NameType, class AgeType&gt;class Person&#123;public: Person(NameType name, AgeTye age)&#123; this-&gt;mName = name; this-&gt;mAge = age; &#125; void PrintPerson()&#123; cout &lt;&lt; "Name: " &lt;&lt; this-&gt;mName &lt;&lt; endl; &#125;public: NameType mName; AgeType mAge;&#125;;void test()&#123; Person&lt;string, int&gt; p("John", 30); p.PrintPerson(); return;&#125; 模板机制剖析或者说, 模板为什么不能跨文件编写? 原因一: 编译器的独立编译原则 编译当前文件时, 不关心也不知道, 另一个文件的情况 比如, 当前文件调用了另一个文件的方法, 但是编译到当前文件时, 并不关心这个方法是否真的实现, 或者实现中有什么错误, 只是单纯的认为, 存在的就是对的. 如果没有实现, 那么交给链接时, 再去报错. 原因二: 模板的二次编译 编译器会对模板进行两次编译, 在声明的地方对模板代码本身进行编译, 在调用的地方对参数替换后的代码进行编译. 模板, 其实也是c++编译器做的众多小动作中一个而已.语法上提供了一些简便的写法–写入一个typename即可替代所有类型. 真正的底层原因就是二次编译, 模板还是模板, 但是在其被真正使用或调用的那一刻, 那么编译器就会为它具体生成一个具体的类型实现. 但是问题来了, 如果分开文件实现, 那么在实现文件中, 由于编译器的单独编译特性, 所以编译到实现文件时, 并不知道当前模板被调用的情况, 因为调用通常是在其他文件. 在模板不知道自己被调用时, 编译器不会为其生成具体的实现, 所以模板调用处, 才产生链接错误, 方法找不到实现.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[struct 与 class in C/C++]]></title>
      <url>%2F2017%2F03%2F24%2Fstruct-%E4%B8%8E-class-in-C-C%2F</url>
      <content type="text"><![CDATA[当你看到不可理解的现象，感到迷惑时，真理可能已经披着面纱悄悄地站在你的面前。—— 巴尔扎克 C 和 C++ 中的 struct 区别 c语言中, struct 只有变量 c++语言中, struct 既可以有变量, 也可以有函数 struct 与 class 区别 class的默认权限为private, struct的默认权限是public]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[引用与指针]]></title>
      <url>%2F2017%2F03%2F24%2F%E5%BC%95%E7%94%A8%E4%B8%8E%E6%8C%87%E9%92%88%2F</url>
      <content type="text"><![CDATA[在任何一个成功的后面都有着十五年到二十年的生活经验，都有着丰富的生活经验，要是没有这些经验，任何才思敏捷恐怕也不会有，而且在这里，恐怕任何天才也都无济于事。—— 巴甫连柯 引用和指针引用是c++对c的重要扩充. 在c/c++中指针的作用基本是一样的, 但c++增加了另外一种给函数传递地址的途径, 就是按引用传递. 变量名实质上是一段连续内存空间的别名, 相当于一个门牌号 一个变量可以有n个别名 程序中通过变量来申请并命名内存空间 通过变量的名字可以使用存储空间 1 引用的基本用法基本语法: Type&amp; ref = val; 注意事项: 1 &amp;在此不是求地址, 而是标识的作用2 类型标识符是指目标变量的类型3 必须在声明引用变量时进行初始化 int&amp; ref; // 报错 4 引用初始化之后, 不能改变 int a = 20; int b = 30; int&amp; ref = a; ref = b; // 报错, 不能改变引用 5 不能用NULL引用. 必须确保引用是和一块合法内存的存储单元关联 建立数组引用:123456789// Type&amp; ref = val;// 方法1typedef int ArrRef[10];int arr[10];ArrRef&amp; ref = arr;// 方法2int(&amp;f)[10] = arr; 2 引用的本质引用的本质在c++内部实现是一个常指针1234Type&amp; ref = val; // Type *const ref = &amp;val;int a = 10;int&amp; ref = a; // 编译器自动转换为 int * const ref = &amp;a; 这也能说明,引用为什么必须初始化, 因为const变量必须被初始化ref = 20; // 自动转换为 *ref = 20; c++编译器在编译过程中,使用常指针作为引用的内部实现, 因此引用所占的空间大小与指针相同, 只是这个过程是编译器内部实现, 用户看不见. 3 指针的引用在c语言中,如果想修改一个指针的指向, 而不是它所指的内容, 函数声明可能这样: void func(int **p) 给指针变量取一个别名:12Type* pointer = NULL;Type*&amp; ref = pointer; 案例:1234567891011121314151617void init_teacher(Teacher** t)&#123; // 初始化&#125;void init_teacher_ref(Teacher*&amp; t)&#123; // 初始化&#125;void test()&#123; Teacher *teacher = NULL; // c语言指针用法 init_teacher(&amp;teacher); // c++中的引用做法, 语法清晰, 不用再取指针的地址 init_teacher_ref(teacher);&#125; 4 常量的引用常用引用的定义格式: const Type&amp; ref = val; 字面量不能赋给引用, 但可以赋值 const 引用123456void test(void)&#123; int a = 100; const int&amp; ref = a; // ref = 200; // 报错; 常引用 a = 200; // OK&#125; const 修饰的引用, 不能修改1234void test01(void)&#123; // int&amp; ref = 100; // 报错; 不能把一个字面量赋给引用 const int&amp; ref = 100;// 编译器的内部处理: int temp = 200; const int&amp; ref = temp;&#125; 5 引用使用的场景常量引用主要用在函数的形参, 尤其是类的拷贝构造函数. 将函数的形参定义常量引用的好处: 1 引用不产生新的变量, 减少形参与实参传递时的开销 2 由于引用可能导致实参随形参改变而改变, 将其定义为常量引用可以消除这种副作用. 6 引用使用时的注意点最常看见引用的地方是在函数参数和返回值中. 参数中: 函数内的任何引用的修改, 将函数外的参数产生改变.12345void refSwap(int&amp; m, int&amp; n)&#123; int temp = m; m = n; n = temp;&#125; 返回值: 函数中返回一个引用, 必须像从函数中返回一个指针一样的对待.当函数返回值时,引用关联的内存一定要存在. 不能返回局部变量的引用 返回静态局部变量的引用, 就ok 函数当左值时, 必须返回引用 test() = 200;// 函数做左值]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[gcc 常用编译指令]]></title>
      <url>%2F2017%2F03%2F24%2Fgcc-%E5%B8%B8%E7%94%A8%E7%BC%96%E8%AF%91%E6%8C%87%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[人生的磨难是很多的，所以我们不可对于每一件轻微的伤害都过于敏感。在生活磨难面前，精神上的坚强和无动于衷是我们抵抗罪恶和人生意外的最好武器。—— 洛克 gcc全称为GNU Compiler Collection（GNU编译套件）。GNU is Not Unix。GNU/Linux。 gcc [-c|-S|-E] [-std=standard] [-g] [-pg] [-Olevel] [-Wwarn…] [-Wpedantic] [-Idir…] [-Ldir…] [-Dmacro[=defn]…] [-Umacro] [-foption…] [-mmachine-option…] [-o outfile] [@file] infile… 预处理编译汇编链接 常用(1) -Wall -Wextra 警告全开,(2) - g 编译调试版本(3) -save-temps 保存中间生成文件]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[const in c++]]></title>
      <url>%2F2017%2F03%2F24%2Fconst-in-c%2F</url>
      <content type="text"><![CDATA[人生中最困难者，莫过于选择。—— 莫尔 0 const概述const字面的意思为常数的,不变的.它是c/c++中的一个关键字,是一个限定符,用来限定一个变量不允许改变,它将一个对象转换成一个常量. 1 c/c++ 中const的区别 c中的const 对于const 修饰的局部变量来说 const修饰的局部变量就是, 一个不能改变的 普通变量, 一个只读的变量 示例:12345678910void test()&#123; const int a;// 报错; 必须初始化, 因为 const 不能被修改, 不初始化赋值的话, 将永远不能被赋值.&#125;void test01()&#123; const int a = 100; a = 10; // 报错, 尝试修改只读变量 // a的地址就在栈区, 而不是常量区,因为它只是一个变量,但是标记为只读.&#125; 局部变量通过指针修改,是可以的. 但是对于全局变量而言: const 修饰全部变量时, 默认是外部链接的.多文件使用同一个变量名, 会造成变量重定义. 全局变量不能通过指针修改, 存储区域放在只读常量区, 修改会直接引发段错误. c++中的const 一个概念需要引出: 常量折叠 其实就是类似宏替换一样,在进行完数据类型检查之后, 为了代码的高效性, 把常量替换成为它所代表的具体的值 直接 折叠到代码当中. 在c++中, 一个const不必创建内存空间. 在c++中, 是否为const常量分配内存空间依赖于如何使用.一般来说, 一个const仅仅用来把一个名字用一个值代替, 那么该存储空间就不必创建. 这时,编译器就会把 用到const的地方, 替换为它对应值, 也就是常量折叠的概念. 但是,对一个const变量取地址之后, 或者把它定义为exten, 则会为该const 变量创建内存空间. 12345678910void test()&#123; const int a = 100;// c++中 // a = 10; // 报错, 尝试修改只读变量 int *p = (int *)&amp;a; *p = 10; printf("%d\n", a);// 打印结果依然是100 printf("%d\n", *(int*)&amp;a); // 10&#125; 原因解析 其实, 都是编译器捣的鬼而已:1 变量a 在编译时, 就被常量折叠, 把所有用到a的地方都被替换成 常数 100, 除了一个地方, 也就是对a取地址的地方2 变量a 的地址就在栈区, 这点跟c是一样的3 指针修改的过程也都没有问题, 查看a的内存地址中的值, 发现a的值也确实被修改了.4 取地址之后, a就有了真实的地址空间, 但是直接打印a时, 打印其实是一个默认的修改之前的常量. c++的编译器,真的让人很无语, 搞这种小把戏, 但是其实也可以看得出来, c++真的是不想让你修改一个const的值, 因为你使用const的意义就在于此啊.而且, 更重要的是, 其实也是c/c++语言的中一个重要的思想体现: 程序员被允许做你能做的一切,你想修改const, 可以, 去做吧, 前提是,你清楚的知道自己在干什么.所以编译器这里所做的是什么?就是为了防止意外的修改而已, 不小心使用指针进行错误修改, 那么编译器还能帮你最后一次. 全局变量: 跟c语言中一样,也不能修改,指针也不行. c++中的全局变量, 默认也是不分配内存, 当声明extern 或者 取地址之后, 才会分配内存, 并且内存存放的地址在只读常量区, 修改直接段错误. 区别是: c++中默认的链接属性是内部链接, 只在本文件内有效. 2 基础类型赋值与自定义类型1 对于基础数据类型, 如果用一个变量初始化 const 变量, 如果 const int a = b, 那么也是会给a分配内存 123456int b = 10;const int constA = b;int* p = (int*)&amp;constA;*p = 300;cout &lt;&lt; "constA:" &lt;&lt; constA &lt;&lt; endl;// 300cout &lt;&lt; "*p:" &lt;&lt; *p &lt;&lt; endl;// 300 此时编译器不会再把 constA 的值替换了(常量折叠), 因为初始化的时候, constA 被一个变量赋值, 而不是一个常数. 这时, 就跟c语言一样了. 2 对于自定义数据类型, 比如类对象, 那么也会分配内存. 12345678const Person person; //未初始化age//person.age = 50; //不可修改Person* pPerson = (Person*)&amp;person;//指针间接修改pPerson-&gt;age = 100;cout &lt;&lt; "pPerson-&gt;age:" &lt;&lt; pPerson-&gt;age &lt;&lt; endl;// 100pPerson-&gt;age = 200;cout &lt;&lt; "pPerson-&gt;age:" &lt;&lt; pPerson-&gt;age &lt;&lt; endl;// 200 为person分配了内存，所以可以通过指针的间接赋值修改person对象。 编译器其实能做的也有限, 只是常数的时候, 才可以进行替换展开, 其他情况, 它也无能为力, 指针就是这么强大呀! 3 尽量使用const来替换 #define区别: 1．const有类型，可进行编译器类型安全检查。#define无类型，不可进行类型检查.2．const有作用域，而#define不重视作用域，默认定义处到文件结尾.如果定义在指定作用域下有效的常量，那么#define就不能用。 4 总结其实, const在c++的应用远远不止于此, 类中还有大量的使用, 类对象, 类方法中, 参数中, 返回值中, 都能见到 const 的身影. 但是, 我们在使用时候坚持一点就好, 如果你用了const ,那么, 你就不要尝试修改, 或者说, 你不想别人修改, 那你就使用const吧. 没人会主动想改, 除非你真的想改, c++尝试在编译器层面做了很多, 但是面对指针, 很多时候, 你也无能为力.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[冷门小技巧 之 C/C++ 持续更新ing]]></title>
      <url>%2F2017%2F03%2F21%2F%E5%86%B7%E9%97%A8%E5%B0%8F%E6%8A%80%E5%B7%A7-%E4%B9%8B-C-C-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0ing%2F</url>
      <content type="text"><![CDATA[把时间用在思考上是最能节省时间的事情.—— 卡曾斯 本文主要介绍的一些冷门的, 诡异的, C/C++方面的小技巧, 持续更新ing. 1. 字符串不需要换行直接使用123456char buf[1024] = "hello" "world" "haha";//效果等价于:char buf[1024] = "helloworldhaha"; 这有什么鬼用呢? 在http组包头的时候,可以直接拼就好了,而已便于观看 1234char buf[1024] = "GET /xxx.html HTTP/1.1\r\n" "Host: 127.0.0.1:80\r\n" "Connection: keep-alive\r\n" "\r\n"; 是不是很好用? 2.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[搭建自己的Blog]]></title>
      <url>%2F2017%2F03%2F21%2F%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84Blog%2F</url>
      <content type="text"><![CDATA[思想以自己的言语喂养它自己，而成长起来。—— 泰戈尔 Hexo搭建记现在想想, 搭建个人的Blog真心是一件麻烦的事情, 每遇到一个问题, 那种痛苦的感觉, 解决了之后, 那种爽快的感觉, 其实跟编程给人的感觉差不多少. 在很久之前就一直想做一个自己的blog, 也买了域名, 折腾了一会, 但是就是感觉没有一篇文章是给小白, 纯小白看的, 就好像说, 把大象关进冰箱一样, 打开冰箱门, 你肯定知道, 然后大神们就告诉你说, 然后把大象放进冰箱里就行, 最后把冰箱门关上, done! 成功了有没有!…. 有些夸张, 但是有时候感受是这样的 前几天,偶然的一次访问到了一位网友的博客, 博客的页面简单, 美观, 实用, 又一次燃起了我对个人主页的向往, 于是, 折腾开始了.. 其实, 网上也参考不少好的资料, 在本文末尾, 也一一列出, 并在此感谢各位大神的著作, 让我度过了坎坷但又很值得的几天, 人生就是要浪费在这种美好的事物上呀! 下面, 我来给出我的详细搭建过程中, 遇到关于域名解析的一些问题, 进行一下简单的说明. 像简单的一些页面配置, 文章最后, 我列出的参考文献之中, 均有详细无比的配置方法, 就不在此赘述. 1.1 购买域名 我是直接去狗爹上, 搜索到自己想要的域名, 然后购买就可以, 简单, 而且可以直接支付宝付款. 1.2 域名解析啥意思呢? 就是说, 你虽然买了一个域名, 但是还是要解析才能使用, 比如说, 我自己买了一个域名是xxxx.me, 但是实际上你托管代码的服务器, 只让你通过www.xxxx.me来访问, 不允许你直接访问自己的域名, 怎么破?这个时候就需要一个dns解析服务, 来帮助, 而且还有一个CNAME的概念. 我使用的DNS解析服务是来自DNSPod, 注册简单, 使用也比较方便, 在域名解析标签下, 添加自己的购买的域名, 然后再根据设置向导, 修改狗爹上的一些配置, 其实就是访问自己的域名时, 狗爹的服务器优先感知到, 然后再反向通知到你刚刚注册的DNSPod的NameServer上去, 进而进行解析, 其实也就是再一步的跳转到你设置的那个真实的服务器的ip地址上去, 获取到你页面文件, 浏览器才能进行展示. 这个再跳转的过程就是 要配置的 CNAME我是使用的GitHub提供的代码托管服务.DNSPod中的CNAME选项按照要求GitHub配置上就好, ‘过程就是, 访问 www.xxx.me , 狗爹服务器响应, 然后跳转到DnsPod服务器, 然后根据CNAME再跳一次, 跳到GitHub的服务器上面, 最后才算是完成了一次访问. 1.3 直接访问域名其实我还有一个问题, 一直没有解决, 就是我CNAME虽然按照DNSPod的方式配置, GitHub的二级域名也填好了, 是直接访问的方式, 但是我直接访问时, 却一直会跳转到狗爹的页面上去, 而不会跳转的GitHub上的部署服务器上, 但是如果使用www访问,就可以直接访问成功.123不知道是不是我购买的域名不支持?还是DNSPod的配置还是有问题?还是GitHub上不支持? 唉 , 以后再慢慢来弄吧~ 先好好写点文章先.. ———-华丽的分割线————- 原来是 想访问到 xxx.me 的域名, CNAME要配置成 @ 才行, 需要将 Dnspod 上的 默认提供的 @ + ip 的访问方式删除掉(否则会提示冲突), 好吧. 现在终于可以去掉恶心的 www了 哈哈 还有每次部署上去的时候, 发现每次都要修改一下github仓库上的setting, 再配置上二级域名才可以, 我也觉得不应该有这么傻的操作, 但是今天终于搞清楚了: 在source目录下, 直接加上一个CNAME文件( 之前一直添加在根目录下的 .deploy 下的 .git 目录下, 唉), 内容就是你要重定向的地址, 也就是你的域名. 参考文献 Hexo你的博客 Hexo独立博客 NexTGitHub Next使用文档]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux多线程传参问题]]></title>
      <url>%2F2017%2F03%2F21%2FLinux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BC%A0%E5%8F%82%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[寿命的缩短与思想的虚耗成正比。—— 达尔文 在Linux多线程创建函数pthread_create中, 它的最后一个参数, 允许线程回调函数中传入一个参数, 一直以来, 我们被警告尽量不要在这个参数中传递指针, 尽量进行值传递.. 但是为什么呢? 下面, 我们来看这样一段代码: 123456789101112131415161718192021222324252627282930313233343536373839typedef struct ThreadInfo_&#123; void *handle; int iLoop; int iArrayIndex;&#125; ThreadInfo;void *start_routine(void *arg)&#123; ThreadInfo *threadInfo = (ThreadInfo *)arg; for( int i = 0 ; i &lt; threadInfo-&gt;iLoop ; ++ i ) printf("第%d线程, 第%d圈", threadInfo-&gt;iArrayIndex, i+1);&#125;int main(void)&#123; pthread_t pidArray[1024]; ThreadInfo threadInfo; memset( &amp;threadInfo , 0 , sizeof(ThreadInfo) ); void *handle = NULL; int iLoop = 2; for( int i = 0 ; i &lt; 10 ; ++ i )&#123; threadInfo.handle = handle; threadInfo.iLoop = iLoop; threadInfo.iArrayIndex = i+1; pthread_create( &amp;pidArray[i] , NULL , start_routine , (void*)&amp;threadInfo ); &#125; for( int i = 0 ; i &lt; 10 ; ++ i ) pthread_join( pidArray[i] , NULL ); return 0;&#125; 很简单的一段逻辑, 我们有这样一个需求: 创建10个线程,每个线程打印: 当前线程在处理第几圈, 打印顺序当然是不确定的 预期: “第1线程, 第1圈”“第2线程, 第1圈”“第3线程, 第2圈”“第4线程, 第1圈”“第5线程, 第2圈”… 实际上: “第10线程, 第1圈”“第10线程, 第1圈”“第10线程, 第2圈”“第10线程, 第1圈”“第10线程, 第1圈”“第10线程, 第2圈”“第10线程, 第1圈”“第10线程, 第2圈”“第10线程, 第2圈”… 打印的结果, 大大的出乎我们的意料, 没有按照我们之前的预想, 都是打印出第10个线程在做事.为什么会这样呢? 原因其实也不难分析: 我们仔细再回顾一下代码, 不难发现一个问题, 那就是threadInfo这个东西, 在主线程中, 其实只被创建了一次, 而每次for循环中, 进行修改它的内容而已. 貌似问题是出在这里, 这还不够. 我们还知道这样几个事实, 那就是这段代码中: 主线程函数栈和子线程函数栈其实都是同一个进程的栈空间内的; 主线程在创建10个子线程的整个过程中, 一直是不会被打断的; 10个子线程看似是一个个创建出来的, 但是其实相当于10个线程并发着创建出来, 然后一起去抢占cpu的资源的; 主线程和子线程抢占cpu的能力上, 大概是 主线程会优先90%抢占, 理论依据不足, 这里主要是经验值. 好, 这几个事实的基础上, 我们知道了10个子线程一起创建好了, 然后去抢占资源, 抢到了然后去执行回调函数, 处理相关的逻辑. 而且, 主线程也不会等待或阻塞, 依次继续执行, 那么, 控制线程编号的变量, iArrayIndex其实本质上, 是在主线程自己的栈帧中的, 开辟关于threadInfo的一段空间, 空间里有一个 iArrayIndex 变量的内容. 再看子线程空间, 线程空间中, 由于是通过指针的方式获取到 threadInfo的值, 那么,线程不断的抢占, 然后通过指针访问主线程栈帧中的一个变量中的一个属性内容, 而且, 这个内容在主线程中不断的自增变化. 而且, 主线程有90%的几率优先抢占到资源, 所以整个for循环执行完, iArraryIndex 已经自增为10, 这时, 子线程们才陆陆续续抢到cpu, 然后去回调, 而且, 还是通过指针, 访问主线程的栈帧中的iArrayIndex变量, 所以打印结果当然全是线程10咯~~ 如何解决呢?1 方法很简单, 尽量不要指针传递因为创建过程中, 被指向的对象很可能已经在主线程中发生变化, 比如本题中.不变化的话, 就可以传了吗? 接着看. 2. 一定要使用怎么办 答案就是: 内存冗余法. 啥意思呢?说白了, 就是避免麻烦, 避免出现本文中的出现的类似的问题, 我给每个子线程生成一个变量就好了, 每人一份, 不用抢. 当然, 这一份变量要开辟在堆空间上. 其实也就是类似, 参考了 多进程中的做法, 就是fork之后, 原来父进程有的, 我几乎全copy一份( 有些PCB中的内容不会拷贝到子进程中去 ), 互不干扰. 总结多线程中的使用中, 这个传参的过程还是有点小坑的, 很多问题, 同一个线程中, 似乎很简单, 但是多线程, 而且感觉看不到摸不到, 调用时机也不明确, 会让我们觉得有点困扰. 但是仔细分析, 画图辅助, 其实问题解决起来也不难. 示意图如下:]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[浅谈算法 之 并查集]]></title>
      <url>%2F2017%2F03%2F20%2F%E6%B5%85%E8%B0%88%E7%AE%97%E6%B3%95-%E4%B9%8B-%E5%B9%B6%E6%9F%A5%E9%9B%86%2F</url>
      <content type="text"><![CDATA[我不能说我不珍重这些荣誉，并且我承认它很有价值，不过我却从来不曾为追求这些荣誉而工作。—— 法拉第 并查集1 概念 并查集本身是一种特殊的树形结构,看似有点奇怪,因为它某些实现方式可能并没有使用到关于树的任何节点之类的东西,但是原理上,就是这样. 2 基础并查集存在的最大意义就是为了,高效地回答一个问题:1isConnect ( int p , int q ) 也就是判断 两个节点是否连接 问题.正是这一点,也是它作为图论基础的一个重要原因,图论关于路径问题很多时候,都会使用并查集这种概念来解决其中一些逻辑.其实很多基础数据结构都是为了辅助高级算法中的某一环节的问题而存在的. 2.1 连接问题 与 路径问题 连接问题相比路径问题,回答的问题要少很多,因为它只关心两个节点是否相连,这也正是并查集高效的根本原因. 一个算法可以回答问题越多,其实不见得这个算法越高效,反而,可能这个算法是越低效的,这一点特别重要.或者说, 一个算法如果回答的问题越少, 其实也是提升算法效率的一个重要思路. 比如: 二分查找法 和 顺序查找法 相比快速排序 partition堆 再看什么是连接的问题? 网络中节点的连接状态用户之间形成的网络道路交通航班调度 2.2 并查集的两个基本操作,是的,就两个:1234find( int p )union( int p , int q)// 注意,这里的union不是联合体的意思,是合并操作的意思 2.3 另外 并查集也可以实现数学中的集合类. 3 实现这里介绍的并查集底层实现方式都是使用数组来实现的. 3.1 QuickFindQuickFind见名知义,就是find操作的实现比较快.问题: 效率太低. 123456789101112131415161718192021222324252627282930class UnionFind&#123;private: int * id; int count;&#125;;// O(1)int find( int p )&#123; assert( p &gt;= 0 &amp;&amp; p &lt; count ); return id[p];&#125;int isConnected( int p , int q)&#123; assert( p &gt;= 0 &amp;&amp; p &lt; count ); assert( q &gt;= 0 &amp;&amp; q &lt; count ); return id[p] == id[q];&#125;// O(n)void unionElements( int p , int q )&#123; int pID = find(p); int qID = find(q); if( qID == pID) return; for( int i = 0 ; i &lt; count ; ++ i ) if( qID == id[i] ) id[i] = pID;&#125; 其实从代码我们也可以看出,其实find操作,在图中的,其实就是查找当前节点所在的连通分量的值.union的操作其实就是合并两个连通分量. 因为对于两个连通分量来说, 只要各自有一个点相连接了, 那么两个连通分量都连在一起了. 3.2 QuickUnionQuickUnion见名知义,就是union操作的实现比较快.思路上,发生了一点变化: 每个节点缓存了自己的父节点的值其实这个思路,就是类似于树的父节点的概念,但是实现了并没有引入指针的概念 问题: 一定程度上,缓解了QuickFind的效率低下的问题,但是还不够 实现如下: 12345678910111213141516171819202122232425262728class UnionFind&#123;private: int * parent; int count;&#125;;int find( int p )&#123; assert( p &gt;= 0 &amp;&amp; p &lt; count ); while( p != parent[p] ) p = parent[p]; return p;&#125;int isConnected( int p , int q)&#123; return find(p) == find(q);&#125;void unionElements( int p , int q )&#123; int pRoot = find(p); int qRoot = find(q); if( qRoot == pRoot) return; // q节点的根节点, 指向p节点的根节点 parent[pRoot] = qRoot;&#125; 虽然实现上并没有引入根节点,或者使用指针概念( 因为并查集中的节点只有父节点概念, 所以用数组来保存节点值即可 ), 但是本质上, 在开头也提到了, 并查集虽然是一棵特殊的树, 但是还是具有树的性质: 当树高度很深时, 树的遍历效率会大大降低. 类似于普通平衡二叉树也有类似的问题,所以才引入了2-3树和红黑树的概念. 在并查集中,也存在这样类似的问题, 所以便有了下面的两种优化 3.2.1 基于size的优化思路也很简单,就是在union操作中,不是随意的将两个连通分量直接合并,而是根据元素的个数,优先将元素少的集合, 合并到元素多的连通分量中. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#ifndef UNIONFIND_UNIONFIND3_H#define UNIONFIND_UNIONFIND3_H#include &lt;cassert&gt;namespace UF3&#123; class UnionFind&#123; private: int * parent; int count; int * sz;// sz[i] 表示i为根节点的集合中元素个数 public: UnionFind( int count )&#123; parent = new int[count]; sz = new int[count]; this-&gt;count = count; for( int i = 0 ; i &lt; count ; ++i )&#123; parent[i] = i; sz[i] = 0; &#125; &#125; ~UnionFind()&#123; delete[] parent; delete[] sz; &#125; int find( int p )&#123; assert( p &gt;= 0 &amp;&amp; p &lt; count ); while( p != parent[p] ) p = parent[p]; return p; &#125; bool isConnected( int p , int q )&#123; return find(p) == find(q); &#125; void unionElements( int p , int q )&#123; int pRoot = find(p); int qRoot = find(q); if( pRoot == qRoot ) return; // 节点少的并到节点多的集合中 if( sz[pRoot] &gt; sz[qRoot] ) &#123; parent[qRoot] = pRoot; sz[pRoot] += sz[qRoot]; &#125; else &#123; parent[pRoot] = qRoot; sz[pRoot] += sz[qRoot]; &#125; &#125; &#125;;&#125;#endif //UNIONFIND_UNIONFIND3_H 3.2.1 基于rank的优化关于size的优化其实可以解决大部分的场景, 但是其实还是不够,还是以上那个情况,就是元素个数,其实并不能完全解决并查集的树高度过深的问题,所以再次修改代码如下:思路很简单, 一句话, 就是把树的高度低的集合合并到高的树的集合中. 100万量级可以做到1s内处理 – union和 判断连接 两个操作. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#ifndef INC_05_OPTIMIZE_BY_RANK_UNIONFIND3_H#define INC_05_OPTIMIZE_BY_RANK_UNIONFIND3_H#include &lt;cassert&gt;using namespace std;namespace UF3&#123; class UnionFind&#123; private: int* parent; int* rank; // rank[i]表示以i为根的集合所表示的树的层数 int count; public: UnionFind(int count)&#123; parent = new int[count]; rank = new int[count]; this-&gt;count = count; for( int i = 0 ; i &lt; count ; i ++ )&#123; parent[i] = i; rank[i] = 1; &#125; &#125; ~UnionFind()&#123; delete[] parent; delete[] rank; &#125; int find(int p)&#123; assert( p &gt;= 0 &amp;&amp; p &lt; count ); while( p != parent[p] ) p = parent[p]; return p; &#125; bool isConnected( int p , int q )&#123; return find(p) == find(q); &#125; void unionElements(int p, int q)&#123; int pRoot = find(p); int qRoot = find(q); if( pRoot == qRoot ) return; if( rank[pRoot] &lt; rank[qRoot] )&#123;// 树的高度不变, 仔细琢磨一下 parent[pRoot] = qRoot; &#125; else if( rank[qRoot] &lt; rank[pRoot])&#123;// 同理, 树的高度也不变 parent[qRoot] = pRoot; &#125; else&#123; // rank[pRoot] == rank[qRoot] // else的逻辑是整段代码的核心 // 高度相等时候的合并, 最后的高度 += 1 即可 parent[pRoot] = qRoot; rank[qRoot] += 1; &#125; &#125; &#125;;&#125;#endif //INC_05_OPTIMIZE_BY_RANK_UNIONFIND3_H 3.2.3 路径压缩其实,也是基于QuickUnion的一个优化,但是优化的重点,放在find上. 在find的过程中,再次通过技术手段,降低树的高度. 1234567891011int find( int p )&#123; assert( p &gt;= 0 &amp;&amp; p &lt; count ); while( p != parent[p] )&#123; // p的父节点指向当前父节点的父节点, 这就是路径压缩的核心, 没了 // 需要注意的就是,即使当前距离根节点只有一个位置了,下面代码依然成立 // 因为根节点的父节点仍然等于自己 parent[p] = parent[parent[p]]; p = parent[p]; &#125; return p;&#125; 继续优化:12345678910int find( int p )&#123; assert( p &gt;= 0 &amp;&amp; p &lt; count ); // 这段代码的作用, 是把所有除根节点外的节点,都直接优化成是根节点的第一子节点 // 也就是说,除了根节点外, 所有节点都在一层, 而树的高度就是两层. // 这样的做法,查找效率就是最高的. if( p != parent[p] ) parent[p] = find( parent[p] ); return p;&#125; 但是, 这只是理论上的分析,实际上,第一个版本的路径压缩优化,在时间效率上其实是高于递归版本的路径压缩优化方法,虽然递归版本中,从逻辑上,树高度上的优化,其实已经做到了极致, 就差把树变成了一个数组, 看似是应该更快的.. 但是, 这其中的消耗其实主要来自递归的开销. 所以,有时候从逻辑上分析之后,我们还应该手动的检验一下最后的结果, 因为理论有时候往往不一定可靠. 4 时间复杂度最终优化后的并查集的操作, 时间复杂度近乎是 O(1) 的, 准确的说不是O(1), 因为其实在操作的过程中, 还是会有一定的开销, 这个消耗的具体内容, 感兴趣的读者可以自行谷歌一下. 算法, 是不是很有意思呢?]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Dynamic & Static Library]]></title>
      <url>%2F2017%2F03%2F20%2FDynamic-Static-Library%2F</url>
      <content type="text"><![CDATA[Microsoft isn’t evil, they just make really crappy operating systems.—— Linus Torvalds 本文是一篇干货,主要展示了Linux和Windows下,静态库和动态库的生成方法. 0 动态库基础1. win下,动态库 -- xxx.dll / xxx.lib xxx.h 2. Linux下,动态库 --- xxx.so xxx.h -L -l 1 Linux(1) 制作Linux动态库 12gcc -c xxx.c -o xxx.o -fPICgcc -shared -o libxxxtest.so xxx.o 多文件项目中,可以参看我的另一篇关于 makefile 的介绍 (2) 动态库的使用 lib库名.so 文件本身不能执行 项目目录结构如下:123456src/ -- xxx.cobj/ -- xxx.o 用于tiainc/ -- xxx.h 头文件lib/ -- xxx.so / xxx.a 库media/ -- 媒体文件Makefile 执行命令如下:123链接器: 工作于生成可重定位文件阶段,也就是生成.o文件.任务:数据合并 和 地址回填(数据位置重定位)动态链接器: 工作于加载器加载可执行文件到内存后,程序运行时查找库函数期间.加载库函数到内存,重定位函数地址(绝对地址),用LD_LIBRARY_PATH. 运行: ./a.out —&gt;报错12原因: 动态链接器找不到加载库函数的目录位置.ldd a.out 查看链接依赖情况, 是否存在&apos;not found&apos;字样 解决方案:12345(1) 将自定义的动态库 cp 放到 标准 c库所在目录位置: /usr/bin/lib (不推荐)(2) 在可执行文件所在目录的位置, 执行命令: export LD_LIBRARY_PATH = 库路径 (临时生效)(3) export LD_LIBRAY_PATH = 库路径 写入 ~/.bash_profile 中, source 一下 令其即时生效, 或重启.ldd 再次查看,成功显示动态库位置 ./a.out 运行即可 2 Windows(1) 动态库的制作: 打开vs2013 , 创建win32 生成dll项目 动态库的命名不要使用中文名 导入src文件 API函数导出即可 只将用户使用的指定某几个函数从动态库中导出。 — xxx.lib 使用 __declspec(dllexport) 宏，提示编译器。在编译程序的时候，需特殊处理的函数。 注意： .c 文件 和 .h 文件 均需要添加该宏！！ （VS2013 要求） 默认生成的动态库位于上层目录下的 Debug 目录内。 (2) 动态库的制作结果12345xxx.dll 二进制目标函数集, 可被操作系统加载xxx.lib 是对dll的描述文件( 包含多少函数, 哪些被导出 )xxx.h 以上三个文件提供给用户使用即可 (3) 动态库的调用和调试1234567通知VS2013编译器，使用提供的动态库。将.dll .lib .h三个文件放置在 .c同级目录下。右键项目“属性”---“配置属性”---“链接器”---“输入”--- “附加依赖项”---下拉菜单“编辑”---- 输入【描述dll信息lib文件 xxxxx.lib】 常见错误：12345678910111. 若xxx.lib配置错误，则VS编译器无法找到所用函数。 2. 如若在运行111.exe时，说明操作系统找不到动态库加载路径。 (1)配置PATH;(2)将exe和动态库dll置于同一目录下即可。VS2015： xxxx.lib ---&gt; .c 源码 .h 头文件所在目录位置 xxxx.dll ---&gt; .exe 可执行文件所在目录位置。 动态库内存释放：12遵循一个原则：谁分配，谁释放。调用动态库函数分配的内存，也一定要调用动态库函数来释放内存。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MakeFile]]></title>
      <url>%2F2017%2F03%2F19%2FMakeFile%2F</url>
      <content type="text"><![CDATA[人的一切痛苦,本质上都是对自己的无能的愤怒—— 王小波 1 定义MakeFile 是一种经典的项目管理工具.其实也是一种脚本,有着自己独特的语法. 2 基本使用Makefile元素:12目标: 依赖 (tab 缩进)命令 目标可以有多个依赖,依赖有传递性.make命令去执行Makefile,Makefile的名字固定为Makefile或者makefile,也可以自定义名字,但需要-f指定. 原理: 当依赖文件, 有更新时, 就会生成新的目标文件, 否则make指令不做什么操作. make默认生成第一个依赖项.如果想生成其他依赖项,直接在make后跟依赖项即可.比如:12345678910111213141516171819202122&gt; make clean# 当makefile文件夹中, 恰好有一个文件名就叫 clean , 那么此时, make clean 动作会失效.# 为什么失效呢?# 因为, 如果目录中出现了&quot;clean&quot;文件，则规则失效了：没有依赖文件，文件&quot;clean&quot;始终是最新的，命令永远不会执行# 也就是, 编译器把 clean 当作了要生成的一个目标文件, # 比如 最简单的 a.out:# gcc a.c -o $@# 如果文件夹中恰好有这样一个 a.out 时, 那么 make 命令就是失效. 同时 clean 的失效也是来自这个道理. clean: rm $@ $(objs) -rf.PHONY: ALL clean# .PHONY: ALL clean 的意思就是强制执行 clean 下的命令, 无视同名文件# 一般可能还要配合sudo命令来使用&gt; make install&gt; make uninstall# 主要用来测试# echo $(CC)&gt; make test 一般的,把第一个目标叫做all 1234# 首次查看,切记要执行, 输出具体指令, 防止误操作造成不可逆转的行为&gt; make -n 3 变量可以使用变量来简化Makefile,定义变量可以使用 定义一个变量12345678# := 表示立即赋值,推荐使用# 也可以使用 = , 使用时才赋值libname := libxxx.so objs := a.o b.o c.oa.out: $(objs) gcc $^ 环境变量shell中的环境变量可以在makefile脚本中直接使用.比如 PATH. 12# 注意空格需要转义才行export objs = a.o\ b.o\ c.o 另外,当本地变量与环境变量重名时,本地变量会覆盖环境变量. 自动变量1234567$^ 在规则的命令中, 表示所有依赖项$&lt; 在规则的命令中, 表示第一个依赖项. 在模式规则中, 可以将依赖项依次取出.$@ 在规则的命令中, 表示目标$? 表示所有比目标文件更&quot;新&quot;的依赖文件列表用于文件拷贝时,有特殊的用途 模式规则: %: %.c gcc $&lt; -o $@ -Wall -g 静态模式规则: $(target):%: %.o gcc $&lt; -o $@ -L$(lib_path) -l$(libname) -I$(inc_path) 4 缺省规则缺省规则是make系统提供的默认的规则,比如 x.o1234567%.o: %.c $(CC) -c $(CPPFLAGS) $(CFLAGS) $&lt;# % 是通配符的意思,表示任意的.o文件# $(CC) 就是cc,也就是gccls -al /usr/bin/cc 可以看出, cc就是gcc的一个软链接而已 5 函数的使用两个函数 1234567891011# 获取含有某一特征的文件组成列表$(wildcard 参数1)使用:srcs = $(wildcard *.c) # srcs = a.c b.c s.c----------------# 替换objs = $(patsubst %.c, %.o , $(srcs)) # 将第三个参数中的,第一个参数的部分,替换为第二个参数objs = a.o b.o s.o 6 一些高级用法主要是shell命令的内置用法 1234srcs := `ls *.c`srcs := $(shell ls *.c)objs := $(srcs:.c=.o) 案例1123456789101112131415CXX = g++ CXXFLAGS = -g -I. -Wall SRCS = $(shell find -name &quot;*.cpp&quot;) OBJECTS = $(SRCS:%.cpp=%.o) TARGETS = $(SRCS:%.cpp=%) all: $(TARGETS) @for target in $(TARGETS); \ do \ $(CXX) $(CXXFLAGS) -o target target.cpp; \ doneclean: -rm -f $(TARGETS) $(OBJECTS) 案例21234567files=main.exe a.exe b.exe all: for name in `echo $(files) | sed s/.exe//g`; \ do \ rm -f &quot;$$name&quot;.o; \ done 1234567891011121314151617181920src = $(wildcard ./src/*.c)obj = $(patsubst ./src/%.c, ./obj/%.o, $(src)) target = $(patsubst ./src/%.c, ./%, $(src))inc_path = ./inclib_paht = ./liblibname = xxxsocketALL:$(target)$(target):./%:./obj/%.o gcc $&lt; -o $@ -L$(lib_paht) -l$(libname) -I$(inc_path)$(obj):./obj/%.o:./src/%.c gcc -c $&lt; -o $@ -L$(lib_paht) -l$(libname) -I$(inc_path)clean: -rm -rf $(obj) $(target).PHONY: ALL clean 7 常见操作目录迭代问题解决方案:(1) 在目录中继续生成一个Makefile文件(2) make -C sub 示例: 子Makefile问题将一些常用的修改属性合并到一个子文件中去命名: def.mk12-include def.mk# 前面的 - 号指的是,如果文件不存在,自动忽略,不要报错 自动推导12&gt; gcc -MM a.c&gt; # 查看a.c的文件依赖命令 方法描述:1234&gt; 临时生成一份 .d 文件&gt; 文件的内容就是 x.o 的所有文件依赖&gt; 只要在makefile文件中下,-include $(deps)也就相当于, 在马克file文件中写入这样依据依赖: a.o: a.c a.h 示例: 7 其他用途文件拷贝123456# 找到A目录下的所有普通文件(1) file_in_A := $(shell find A -type f)(2) Makefile: $(file_in_A) cp $? b # 复制所有最近更新的文件 touch Makefile 8 最后 因为makefile的写法还是过于复杂,现在实际应用中已经较少有人使用makefile,与之替代的是CMake和QMake,但是底层其实都是基于makefile的实现,所以关于makefile我们还是要知道了解一些为好.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[浅谈算法 之 索引堆]]></title>
      <url>%2F2017%2F03%2F19%2FIndexHeap%2F</url>
      <content type="text"><![CDATA[没有人不爱惜他的生命，但很少人珍视他的时间。—— 梁实秋 这里主要讨论的是，数组化的实现堆的经典方法。 1 为什么要使用索引堆 索引堆从名称也可以看得出来，是堆的一种高级形态 有这样一个基础概念，想在此强调一下，那就是： 对于堆化的过程中，原来数组的索引将被破坏掉。 这也是就是索引堆的意义，或者说索引堆的核心价值。 就是因为普通堆在成堆之后，数组的高效索引能力被严重破坏掉，因为成堆之后的下标与原始数据之后没有做关系维护。 这个时候就需要另外一个数组来维护原始数据和成堆后的数据之间的关系。 另外，还有一个问题： shiftUp和shiftDown中的交换操作 在普通堆中，shiftUp和shiftDown中都要进行一步交换两个节点之间的值的步骤，但是如果节点值只是简单的数字，也是交换操作不会造成太大的影响，但是如果不是数字呢，而是一个字符串，或者一个更大的数据类型时，那么交换带来的副作用将会被大大提升。 p.s. 当然这里交换的操作，我们可以简单的通过一些技术手段来替代。 所以，这时，我们的英雄登场了：索引堆，先来看看它的数据结构。 2 索引堆的数据结构索引堆在普通堆的基础之上，其实多维护了一个indexes数组而已，它记录着data中的索引，在堆中的位置，也就是indexes[i] = x 的意思就是，data[x]这个元素，在堆中的实际位置是 i。 看下索引堆的数据结构：123456template &lt;typename Item&gt;class IndexMinHeap&#123;private: Item * data; int * indexes;&#125;; 3 索引堆过程索引堆的整个操作中，并没有对原始数据进行任何操作（只是用来比较），而真正处理的索引数组indexes中的索引，把索引进行了一次堆排序。 这样就根本上避免了数组中交换元素可能带来的副作用，而且相应的带来另外一个巨大的好处：直接可以索引到6号元素——data[6]，这在原始堆的实现过程中，是无法实现的，因为堆的索引性质在成堆过程中被破坏，只能简单的拿到堆的根节点（最大或者最小）。 因为成堆的过程，数组变成一棵树的容器，索引性还在，但是树中的，尤其在堆中的这种树，其实我们只关心根节点，对其他任何节点没有索引意义，原来的第6号元素，跟现在树中的6号元素没有任何关联。 但是，索引堆的中data数组没有被修改，仍然是一个数组性质，而且还可以通过indexes数组找到，data中元素在堆中的位置，indexes[位置] = data对应的下标，如简单的，根节点的位置就是 indexes[1] 的值，也就是data中对应元素的下标位置。 4 调整优先级而且，还可以进行一个重要的操作：change 修改原始数据的优先级，或者可以简单的理解为，修改了原始数据的值。 wow, this really kicks original heap&#39;s ass 5 Reverse 数组索引堆如此厉害，但是与此同时，又带来了一个新的问题： indexes数组成堆的过程中，indexes数组的索引意义也不在了，我们不能快速的（O(1)）获取到，比如1号索引在堆中的位置，因为所有的索引都被打乱了。 所以在change过程中，我们获取到了data元素的下标，如果得知这个下标在堆中的位置呢？ 这个时候，就又用到了一个数组，来维护indexes数组中的下标与堆中位置的关系，也就是reverse数组。 再看下，此时的索引堆的数据结构：1234567template &lt;typename Item&gt;class IndexMinHeap&#123;private: Item * data; int * indexes; int * reverse;&#125;; 可能上面的说法，还是不足够清晰的表达出来，到底reverse数组的意义是什么？ 其实主要就为了一个change函数可以以 O(1) 的时间复杂度来访问到，要修改的元素在索引堆的位置。 简单的，我们可以得到以下的等式：1234567// 堆中i位置上对应的data的下标，也就是j// 也就是data[j]，在堆中的实际位置是i// 或者说，堆中i的位置是，data[j]的下标jindexes[i] = j;// 堆中j的位置是，indexes[i]的下标ireverse[j] = i; 所以呢，再次看出来，如果想与堆中的索引建立联系，必须要多维护一个数组。 6 不断维护Reverse和Indexes数组 只要是操作indexes的地方，都要相应的操作reverse数组，进行匹配 7 应用 对索引堆的使用，在图论中关于有权图，单源最短路径问题的算法中，比如Dijkstra算法和Bellman-Ford算法中都有使用，用来维护最短权值的数组。 最后，附上源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163#ifndef INDEXMINHEAP_INDEXMINHEAP_H#define INDEXMINHEAP_INDEXMINHEAP_H#include &lt;cassert&gt;#include &lt;algorithm&gt;template &lt;typename Item&gt;class IndexMinHeap&#123;private: // 原始数据，对原始数据并不需要进行实际的操作，下标不变 Item * data; // indexes[i]表示堆中第i个元素在data中索引 // 比如indexes[1] = 10，也就是说，堆的根节点，是data中的10号元素 int * indexes; // reverse[i]表示索引i在indexes(堆)中的位置 // reverse[10] = 1，也就是说，10号索引在堆中的位置是1号元素，也就是根节点 // reverse[x] = 0; 表示索引不存在 int * reverse; int count; int capacity; void shiftUp( int k )&#123; while( k &gt; 1 &amp;&amp; data[indexes[k]] &lt; data[indexes[k/2]] )&#123; std::swap( indexes[k] , indexes[k/2] ); reverse[indexes[k]] = k; reverse[indexes[k/2]] = k/2; k /= 2; &#125; &#125; void shiftDown( int k )&#123; while( 2*k &lt;= count )&#123; int i = 2*k; if( i+1 &lt;= count &amp;&amp; data[indexes[i]] &gt; data[indexes[i+1]] ) i += 1; if( data[indexes[k]] &lt;= data[indexes[i]] ) break; std::swap( indexes[k] , indexes[i] ); reverse[indexes[k]] = k; reverse[indexes[i]] = i; k = i; &#125; &#125;public: IndexMinHeap( int capacity )&#123; data = new Item[capacity+1]; indexes = new int[capacity+1]; reverse = new int[capacity+1]; for( int i = 0 ; i &lt; capacity ; ++ i ) reverse[i] = 0; this-&gt;capacity = capacity; this-&gt;count = 0; &#125; ~MinHeap()&#123; delete[] data; delete[] indexes; delete[] reverse; &#125; int size() const&#123; return count; &#125; int isEmpty() const&#123; return count == 0; &#125; // 传入的i对于用户而言，是从0开始索引的 void insert( int i , Item item )&#123; assert( count + 1 &lt;= capacity ); assert( i + 1 &gt;= 1 &amp;&amp; i + 1 &lt;= capacity ); i += 1; count += 1; data[i] = item; indexes[count] = i;// 把data中的索引i，放入indexes数组 reverse[i] = count;// 把indexes中的索引i，放入reverse数组 shiftUp( count ); &#125; Item extractMin()&#123; assert( count &gt; 0 ); Item ret = data[indexes[1]]; std::swap( indexes[1] , indexes[count] ); reverse[indexes[1]] = 1; reverse[indexes[count]] = 0; count --; shiftDown( 1 ); return ret; &#125; int extractMinIndex()&#123; assert( count &gt; 0 ); int ret = indexes[1] - 1;// 返回从0开始的索引值 std::swap( indexes[1] , indexes[count] ); reverse[indexes[1]] = 1; reverse[indexes[count]] = 0; count --; shiftDown( 1 ); return ret; &#125; Item getMin()&#123; assert( count &gt; 0 ); return data[indexes[1]]; &#125; int getMinIndex()&#123; assert( count &gt; 0 ); return indexes[1] - 1;// 返回从0开始的索引值 &#125; // 对用户而言，参入的参数就是实际的数据的下标，且是从0开始的索引 Item getItem( int i )&#123; assert( i+1 &gt;= 1 &amp;&amp; i+1 &lt;= capacity ); return data[i+1]; &#125; bool contain( int i )&#123; assert( i + 1 &gt;= 1 &amp;&amp; i + 1 &lt;= capacity ); return reverse[i+1] != 0; &#125; void change( int i , Item newItem )&#123; i += 1; data[i] = newItem; // 找到indexes[j] = i, j表示data[i]在堆中的位置 // 之后shiftUp，再shiftDown ( 先shiftDown，再shiftUp也可以 )// for( int j = 1 ; j &lt;= count ; ++ j )// if( indexes[j] == i )&#123;// shiftUp( j );// shiftDown( j );// return;// &#125; int j = reverse[i]; shiftUp( j ); shiftDown( j ); &#125;&#125;;#endif //INDEXMINHEAP_INDEXMINHEAP_H]]></content>
    </entry>

    
  
  
</search>
